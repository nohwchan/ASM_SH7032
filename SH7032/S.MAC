;***********************************************************************
;       Program for Speed Loop Vector Control
;       By   : SOPON SMAIRATH
;***********************************************************************
        .EXPORT _POWER_RESET_PC,_POWER_RESET_SP
        .EXPORT _MANUAL_RESET_PC,_MANUAL_RESET_SP;,_IMIA0
        .EXPORT DELAY,SCAN,LOOP,LOOP1,FUNCTION
        .IMPORT TRX1WORD,INIT_SSC,SHOW_R10_D,INITPWM,KEYPROC
        .IMPORT INIT_FOUT,_INVALID_SLOT,EE_WR,EE_RD,EE_EN,MOTOR_PARA
        .IMPORT READ_AD,PARA_SET,IMIA3,SQ_ROOT,FRE_TO_WM
        .IMPORT FRE_TO_RPM,CHK_SUM,INITIALIZE,STORE_TEMP
        .INCLUDE "MACRO.H"          ;(MUL,DIV)
        .INCLUDE "RAM_EXP.H"

        .SECTION MAIN,CODE,ALIGN=4
_POWER_RESET_PC:
_MANUAL_RESET_PC:

MAIN:
        MOV   BCR,R0
        MOV   BCRVALUE,R1
        MOV.W R1,@R0

        MOV   WCR1,R0
        MOV   WCR1VALUE,R1
        MOV.W R1,@R0

        MOV   WCR2,R0
        MOV   WCR2VALUE,R1
        MOV.W R1,@R0

        MOV   WCR3,R0
        MOV   WCR3VALUE,R1
        MOV.W R1,@R0

        BSR  DOWN_LOAD_RAM
        NOP

        MOV  RUN_RAM,R10
        MOV  EXT_RAM_ST,R1
        LDC  R1,VBR
        JMP  @R10
        NOP

        .ALIGN 4
        ;*********************************
        ; DOWN LOAD CODE TO EXTERNAL RAM
        ;*********************************   
DOWN_LOAD_RAM:
		MOV	#0,R0		;ROM CODE
		MOV	EXT_RAM_ST,R1	;RAM START ADDRESS
		MOV	RAM_SIZE,R2	;RAM SIZE = BYTES
DWN_CON:
		MOV.B	@R0+,R3

		SHLL8	R3
		MOV.B	@R0+,R5
		MOV	MASKFF,R4
		AND	R4,R5
		OR	R5,R3

		MOV.W	R3,@R1
		ADD	#2,R1		;INC R1
		ADD	#-2,R2
		CMP/PL	R2		;IF R2>0 : T=1
		BT	DWN_CON
		RTS
                NOP

                        .ALIGN 4
EXT_RAM_ST:             .DATA.L H'09000000
RAM_SIZE:               .DATA.L 32768*2
RUN_RAM:                .DATA.L ST_RUN
MASKFF:                 .DATA.L H'FF
                        .ALIGN 4
ST_RUN:
	MOV  IRAM_SIZE,R0
	MOV  IRAM,R2
	MOV  #0,R1
CLR_IRAM:
	MOV.B  R1,@R2
	ADD  #1,R2
	ADD  #-1,R0
	CMP/PZ R0
	BT   CLR_IRAM
        BRA  ST_INIT
        NOP
        .ALIGN 4
IRAM_SIZE:.DATA.L 8192
IRAM:     .DATA.L H'FFFE000
WCR1VALUE:.DATA.L B'1110110011111111
WCR2VALUE:.DATA.L B'1110110011111100
WCR3VALUE:.DATA.L B'0011100000000000
WCR1:    .DATA.L H'5FFFFA2
WCR2:    .DATA.L H'5FFFFA4
WCR3:    .DATA.L H'5FFFFA6
BCRVALUE:.DATA.L B'0011000000000000
BCR:     .DATA.L H'5FFFFA0
         .ALIGN 4
ST_INIT:
        MOV  INITSSC,R0
        JSR  @R0
        NOP

        MOV DIGIT1,R1
        MOV #B'00001000,R2
        SHLL R2
        MOV.B R2,@R1

        MOV DIG_CNT0,R1
        MOV #3,R2
        MOV.B R2,@R1

        MOV DIG_TOG0,R1
        MOV #3,R2
        MOV.B R2,@R1

        MOV BLNKT1,R1
        MOV #H'0,R2
        MOV.W R2,@R1

	MOV BLNKT_TIME,R2
	MOV BLK_T,R1
	MOV.W R2,@R1

        MOV DATA_BUFF11,R11
        ADD #4,R11
        MOV.B @R11,R0
        MOV #0,R0
        MOV.B R0,@R11

        MOV SYSFLG011,R1
        MOV #0,R2
        MOV.W R2,@R1

        MOV POINT011,R1
        MOV #5,R2
        MOV.B R2,@R1

        MOV APY,R10
        MOV DATA_BUFF11,R11
        MOV R10,@R11
        MOV SHOW_T,R13

SHOW_LOGO:
        ADD #-1,R13
        MOV R13,@-SP
	MOV SCAN2,R14
        JSR @R14;SCAN
        NOP
        MOV L_DLY,R0
LOGO_DLY:
        ADD #-1,R0
        CMP/EQ #0,R0
        BF  LOGO_DLY

        MOV @SP+,R13
        MOV R13,R0
        CMP/EQ #0,R0
        BF  SHOW_LOGO

        MOV PBDR_H,R10
        MOV.B @R10,R0
        AND #B'10111111,R0
        MOV.B R0,@R10       ;ON MAG
;CORRECT1----------------BEGIN------------------------------------
        MOV WSTATUS8,R1
        MOV.B @R1,R0
        OR  #B'1000000,R0
        MOV.B R0,@R1
;CORRECT1-----------------END-------------------------------------

        MOV DIG_TOG0,R1
        MOV #4,R2
        MOV.B R2,@R1

        .INCLUDE "INIT_V.H"

        BRA CONTINUE1
        NOP

;        MOV C480,R10          ;READ EE
;        MOV #115,R11
;        MOV EEWR,R0;
;        JSR @R0
;        NOP
        .ALIGN 4
INITSSC:    .DATA.L INIT_SSC
DIG_TOG0: .DATA.L _DIG_TOG
DIGIT1:  .DATA.L _DIGIT
DIG_CNT0:.DATA.L _DIG_CNT
BLNKT1:  .DATA.L BLNKT
BLNKT_TIME: .DATA.L H'2FF/2
BLK_T:  .DATA.L _BT_DAT
SCAN2:  .DATA.L SCAN
MSEC11:  .DATA.L MSEC
SEC11:   .DATA.L SEC
L_DLY:   .DATA.L 1000
PBDR_H:  .DATA.L H'5FFFFC2
APY:     .DATA.L B'01011101001011110110111100000000 ;'Y','P','A',' '
SHOW_T:  .DATA.L 3500
POINT011: .DATA.L  POINT
DATA_BUFF11: .DATA.L _DATA_BUF
SYSFLG011:   .DATA.L SYSFLG
TMPB1:   .DATA.L TMPB
DBOUNCE0:.DATA.L DBOUNCE
WSTATUS8:.DATA.L _W_STATUS
        .ALIGN 4

CONTINUE1:

	.INCLUDE "PASSWORD.H"

	.INCLUDE "PRO_SIZE.H"

	.INCLUDE "AUTO_SET.H"

	.INCLUDE "APY_CODE.H"


        MOV #0,R10           ;READ EE
        MOV #100,R11         ;GET IINV SCALE 10
        MOV EERD,R0
        JSR @R0
        NOP
        MOV #10,R0              ;SCALE 10
        MULS R0,R10
        STS MACL,R10
        MOV IINV,R0             ;STORE IINV SCALE 100
        MOV R10,@R0

        MOV #0,R10          ;READ EE
        MOV #104,R11
        MOV EERD,R0
        JSR @R0
        NOP

        MOV FSET_,R1
        ;MOV #50,R10
        MOV.W R10,@R1
        MOV FLAST01,R1
        ;MOV #50,R10
        MOV.W R10,@R1
;FLYINGA
MOV #0,R10          ;READ EE
MOV #116,R11
MOV EERD,R0
JSR @R0
NOP
MOV FTEMP1,R1
MOV.W R10,@R1
;FLYINGA

;BRA NOT_ERROR
;NOP
        MOV #0,R10
        MOV #127,R11
        MOV EERD,R14
        JSR @R14;EE_RD
        NOP
        MOV SUMMING,R14
        JSR @R14;CHK_SUM
        NOP
        CMP/EQ R8,R10
        BT  NOT_ERROR
        MOV TIP_TYP02,R0
        MOV #7,R1               ;set trip type = 7
        MOV.B R1,@R0
        MOV SYSFLG01,R1
        MOV.B @R1,R0
        OR  #B'1000,R0          ;set trip flag
        AND #B'11111000,R0      ;set stop,not p_mode and blink mode
        MOV.B R0,@R1
NOT_ERROR:

MOV TIP_TYP02,R1
MOV #255,R0
MOV.B R0,@R1

        MOV SYSFLG01,R1
        MOV #0,R0
        MOV.B R0,@R1
        MOV PSTATUS1A,R1
        MOV.B R0,@R1
        MOV KEYCODE_,R1
        MOV.B R0,@R1
        MOV OLDKEY_,R1
        MOV.B R0,@R1


	MOV PARASET,R10
        JSR @R10;PARA_SET
        NOP

        MOV DATA_BUF11,R11
        ADD #4,R11
        MOV.B @R11,R0
        OR #B'00100000,R0
        MOV.B R0,@R11
        BRA INITIAL
        NOP

        .ALIGN 4
DATA_BUF11: .DATA.L _DATA_BUF
SYSFLG01:.DATA.L SYSFLG
;TMPB1:   .DATA.L TMPB
;DBOUNCE0:.DATA.L DBOUNCE
EEWR:    .DATA.L EE_WR
C480:    .DATA.L 480
PSTATUS1A:.DATA.L _P_STATUS
KEYCODE_: .DATA.L KEYCODE
OLDKEY_: .DATA.L OLDKEY
FTEMP1:  .DATA.L _F_TEMP

        .ALIGN 4
INITIAL:

;        MOV INIT_PWM,R0
;        JSR @R0
;        NOP


        MOV INITFOUT,R0
        JSR @R0
        NOP
        MOV MOTOR_PAR,R0
        JSR @R0
        NOP
CHECK_SEARCH:
;FLYINGA
MOV QSTATUS5,R5
MOV.B @R5,R0
TST #B'1000000,R0               ;IF USER NOT SELECT AUTO-RESTART
BT  NOT_SEARCH2                 ;THEN GO TO NOT_SEARCH
MOV PSTATUS6,R1
MOV.B @R1,R0
TST #B'100,R0                   ;IF RUN BY KEYPAD
BT  NOT_SEARCH2                 ;THEN NOT_SEARCH
MOV INP4,R1                     ;ELSE CHECK FWD_RWD CONTINUE
MOV.W @R1,R0
AND #B'00110000,R0
TST #B'00100000,R0              ;IF FWD SIGNAL NOT IN
BT  REVERSE1                    ;THEN CHK REVERSE CONTINUE
TST #B'00010000,R0              ;ELSE IF RWD SIGNAL IN(BOTH FWD & REW IN)
BF  NOT_SEARCH2                 ;THEN NOT_SEARCH
BRA SET_SEARCH1
NOP
REVERSE1:
TST #B'00010000,R0              ;IF REW SIGNAL NOT IN(BOTH FWD & REW NOT IN)
BT  NOT_SEARCH2                 ;THEN NOT_SEARCH2

SET_SEARCH1:
MOV VSTATUS6,R1
MOV.B @R1,R0
OR  #B'10000,R0                 ;SET SEARCH FLG.
MOV.B R0,@R1
BRA NOT_SEARCH3
NOP
NOT_SEARCH2:
MOV WSTATUS3,R1
MOV.B @R1,R0
TST #B'1,R0                     ;IF USER SELECT FN-22 = "1"
BF  NOT_SEARCH3                 ;THEN NOT_SEARCH1(NOT CLEAR FLG.)
MOV VSTATUS6,R1
MOV.B @R1,R0
AND #B'11101111,R0              ;CLEAR SEARCH FLG.
MOV.B R0,@R1
NOT_SEARCH3:
;FLYINGA

	MOV RSTCSR,R0
	MOV RST_DAT,R10
	MOV.W R10,@R0

	MOV TCSR,R0
        MOV TCSR_DAT,R10
	MOV.W R10,@R0

;       MOV #B'11111111,R10
;       MOV #103,R11
;       MOV WREE,R0
;       JSR @R0
;       NOP

LOOP2K:
        MOV TCSR,R0		;TCNT IS THE SAME ADD. AS TCSR
        MOV TCNT_DAT,R10	;WRITE 0 TO CLR. WATCHDOG
        MOV.W R10,@R0
	MOV IMIA3_,R10
	JSR @R10
	NOP
NOT2K:
	MOV INTCNT,R1
	MOV.B @R1,R0
	MOV INTLOOP,R2
        MOV.B @R2,R2
	CMP/GE R2,R0
        BF  NOT2K
	MOV #0,R0
	MOV.B R0,@R1
        BRA LOOP2K
        NOP

NOT2K1: ADD #-1,R2
        CMP/EQ R2,R0
        BF  NOT2K
        MOV BRB3B1,R4
        MOV.W @R4,R1
        MOV BRA4B1,R5
        MOV.W @R5,R2
        MOV BRB4B1,R6
        MOV.W @R6,R3
        MOV BRB3,R4
        MOV.W R1,@R4
        MOV BRA4,R5
        MOV.W R2,@R5
        MOV BRB4,R6
        MOV.W R3,@R6
        BRA NOT2K
        NOP

        .ALIGN 4
;EXT_RAM:
;        .DATA.L H'0C000000
;INITSSC:    .DATA.L INIT_SSC
;APY:     .DATA.L B'01011101001011110110111100000000 ;'Y','P','A',' '
;SHOW_T:  .DATA.L 3500
;DIG_TOG0: .DATA.L _DIG_TOG
;DATA_BUF11: .DATA.L _DATA_BUF
;POINT011: .DATA.L  POINT
;DIGIT1:  .DATA.L _DIGIT
;DIG_CNT0:.DATA.L _DIG_CNT
;BLNKT1:  .DATA.L BLNKT
;BLNKT_TIME: .DATA.L H'2FF/2
;BLK_T:  .DATA.L _BT_DAT
;SYSFLG01:.DATA.L SYSFLG
TIP_TYP02: .DATA.L TIP_TYP
IMIA3_: .DATA.L IMIA3
INTCNT: .DATA.L INT_COUNT	
INTLOOP:.DATA.L INT_LOOP
;SCAN2:  .DATA.L SCAN
TCSR:   .DATA.L H'5FFFFB8
RSTCSR:	.DATA.L H'5FFFFBA
TCSR_DAT:.DATA.L H'A57E;A
RST_DAT:.DATA.L H'5A5F
TCNT_DAT:.DATA.L H'5A00
;MSEC11:  .DATA.L MSEC
;SEC11:   .DATA.L SEC
;L_DLY:   .DATA.L 1000
;PBDR_H:  .DATA.L H'5FFFFC2
;TMPB1:   .DATA.L TMPB
;DBOUNCE0:.DATA.L DBOUNCE
INIT_PWM:.DATA.L INITPWM
INITFOUT:.DATA.L INIT_FOUT
FLAST01: .DATA.L FLAST
FSET_:   .DATA.L FSET
PARASET: .DATA.L PARA_SET
RPMSCALE1: .DATA.L RPM_SCALE
EERD:     .DATA.L EE_RD
RPMLAST2: .DATA.L  _RPM_LAST
MCSCALE1: .DATA.L MC_SCALE
MCMUL1:   .DATA.L MC_MUL
MCLAST2:  .DATA.L MC_LAST
IINV:	  .DATA.L I_INV
WREE:	  .DATA.L EE_WR
MOTOR_PAR:.DATA.L MOTOR_PARA
BRB3B1: .DATA.L BRB3B
BRA4B1: .DATA.L BRA4B
BRB4B1: .DATA.L BRB4B
BRB3:   .DATA.L H'5FFFF2E
BRA4:   .DATA.L H'5FFFF3C
BRB4:   .DATA.L H'5FFFF3E
SUMMING:  .DATA.L CHK_SUM
PSTATUS6: .DATA.L _P_STATUS
VSTATUS6: .DATA.L _V_STATUS
INP4:     .DATA.L INPORT
WSTATUS3: .DATA.L _W_STATUS
QSTATUS5: .DATA.L _Q_STATUS

;***********************
; INT. SWITCH TIME BASE
;***********************
        .ALIGN 4
LOOP1:
        STS.L PR,@-SP
        MOV SYS_FLG,R0
        MOV.B @R0,R0

;	OR #B'1000,R0			;SIMULATION FAULT CONTACT

	TST #B'1000,R0
	BF  TRIP_M
	BRA NO_TRIP
	NOP
;*********************
;  TRIP MODE
;*********************
TRIP_M:
;        MOV PADR_L1,R1           ;OUT FAULT SIGNAL TO PA1
;        MOV.B @R1,R0             ;EXT ROM
;        AND #B'11111101,R0
;        MOV.B R0,@R1

        MOV PBDR_L1,R1            ;OUT FAULT SIGNAL TO PB1 INT ROM
        MOV.B @R1,R0
        AND #B'11111101,R0
        MOV.B R0,@R1

        MOV POINT01_,R0
	MOV #5,R1
	MOV.B R1,@R0

        MOV TIP_TYP01,R1
	MOV.B @R1,R0

;	MOV #0,R0			;SIMULATION FAULT CONTACT

	CMP/EQ #0,R0
	BT OC_TRIP
	CMP/EQ #1,R0
	BT OH_TRIP
	CMP/EQ #2,R0
	BT OL1_TRIP
	CMP/EQ #3,R0
	BT OL2_TRIP
	CMP/EQ #4,R0
	BT LU_TRIP
	CMP/EQ #6,R0
	BT CL_TRIP
        CMP/EQ #7,R0
        BT EE_TRIP
        CMP/EQ #14,R0
        BT NO_OP_TRIP
        CMP/EQ #15,R0
        BT PL_TRIP
        ;OU TRIP
	MOV DATA_BUF1,R11
	MOV OU_T,R10
	MOV R10,@R11
	BRA SHOW_DBUF
	NOP
OC_TRIP:
        MOV RSTATUS_1,R1
        MOV.B @R1,R0
        TST #B'100000,R0
        BT  OC_123
        MOV OC_T4,R10
        BRA OC_SHOW
        NOP
OC_123:
        MOV USTATUS,R1
        MOV.B @R1,R0
        TST #B'10000,R0
        BT  OC_23
        MOV OC_T1,R10
        BRA OC_SHOW
        NOP
OC_23:
        MOV SYS_FLG,R1
        MOV.B @R1,R0
        TST #B'100000,R0
        BT  OC_3
        MOV OC_T2,R10
        BRA OC_SHOW
        NOP
OC_3:
        MOV OC_T3,R10

OC_SHOW:
        MOV VSTATUS_1,R1
        MOV.B @R1,R0
        TST #B'1000,R0
        BT  OC_SHOW1
        MOV DOUBLE,R0
        OR  R0,R10
OC_SHOW1:
        MOV DATA_BUF1,R11
        MOV R10,@R11
	BRA SHOW_DBUF
        NOP
OH_TRIP:
	MOV DATA_BUF1,R11
	MOV OH_T,R10
	MOV R10,@R11
	BRA SHOW_DBUF
	NOP
OL1_TRIP:
	MOV DATA_BUF1,R11
	MOV OL1_T,R10
	MOV R10,@R11
	BRA SHOW_DBUF
	NOP

OL2_TRIP:
	MOV DATA_BUF1,R11
	MOV OL2_T,R10
	MOV R10,@R11
	BRA SHOW_DBUF
	NOP

LU_TRIP:
	MOV DATA_BUF1,R11
	MOV LU_T,R10
	MOV R10,@R11
	BRA SHOW_DBUF
	NOP
CL_TRIP:
	MOV DATA_BUF1,R11
	MOV CL_T,R10
	MOV R10,@R11
	BRA SHOW_DBUF
	NOP
EE_TRIP:
	MOV DATA_BUF1,R11
        MOV EE_T,R10
	MOV R10,@R11
	BRA SHOW_DBUF
        NOP
PL_TRIP:
	MOV DATA_BUF1,R11
        MOV PL_T,R10
	MOV R10,@R11
	BRA SHOW_DBUF
        NOP
NO_OP_TRIP:
	MOV DATA_BUF1,R11
        MOV N_OP_T,R10
	MOV R10,@R11
	BRA SHOW_DBUF
        NOP
        
NO_TRIP:
        TST #B'10,R0
        BF  PRG
        BRA NOT_PRG
        NOP
;*********************
;  PROGRAM MODE
;*********************
PRG:
        MOV S_STATUS2,R1
	MOV.B @R1,R0
	TST #B'1000,R0
	BT  NOT_PASS
	MOV PASS,R10
        MOV POINT01_,R1
	MOV #5,R0
	MOV.B R0,@R1
	BRA SHOW_DBUF
	NOP
NOT_PASS:
        MOV TSTATUS_,R1
        MOV.B @R1,R0
        TST #B'10000000,R0
        BT  NOT_SHOW_IINV
        MOV IINV1,R1
        MOV @R1,R10
        MOV #10,R1
        DIVS R1,R10
        MOV #1,R2
	BRA S_PT
        NOP
NOT_SHOW_IINV:
        MOV USTATUS4,R1
        MOV.B @R1,R0
        TST #B'1,R0
        BT  NOT_SHOW_HP
        .INCLUDE "RE_SIZE.H"
NOT_SHOW_HP:
        MOV USTATUS4,R1
        MOV.B @R1,R0
        TST #B'100000,R0
        BF  SH_DATA

        MOV PROGADD1,R1
        MOV.B @R1,R10
        BRA SHOW
        NOP
SH_DATA:

        MOV PROG_DAT2,R10
        MOV.W @R10,R10
        BRA SHOW
        NOP

;        MOV PROG1,R1
;        MOV.W @R1,R1
;        MOV PROG_DAT2,R10
;        MOV.B @R10,R10
;        ADD R1,R10
;        BRA SHOW
;        NOP

        .ALIGN 4
SYS_FLG:       .DATA.L SYSFLG
PADR_L1:       .DATA.L H'5FFFFC1
PBDR_L1:       .DATA.L H'5FFFFC3
POINT01_:      .DATA.L POINT
TIP_TYP01:     .DATA.L TIP_TYP
PROGADD1:      .DATA.L PROG_ADD
PROG_DAT2:     .DATA.L PROG_DAT
PROG1:         .DATA.L PROG
RSTATUS_1:      .DATA.L _R_STATUS
VSTATUS_1:      .DATA.L _V_STATUS
OC_T4:   .DATA.L B'01001101000010000011011001110111
OC_T3:   .DATA.L B'01011011000010000011011001110111
OC_T2:   .DATA.L B'00111011000010000011011001110111
OC_T1:   .DATA.L B'01000001000010000011011001110111
OU_T:          .DATA.L B'00000000011101010111011100000000
OC_T:          .DATA.L B'00000000001101100111011100000000    ;' ','C','O',' '
OH_T:          .DATA.L B'00000000011011010111011100000000
OL1_T:         .DATA.L B'01000001000010000011010001110111
OL2_T:         .DATA.L B'00111011000010000011010001110111
LU_T:          .DATA.L B'00000000011101010011010000000000
CL_T:          .DATA.L B'00000000001101000011011000000000
PASS:          .DATA.L B'01011110010111100110111100101111
EE_T:          .DATA.L B'01000001001010000010100000111110
PL_T:          .DATA.L B'00000000001101000010111100000000
N_OP_T:        .DATA.L B'00101111011101110001000001101000   ;'P','O','_','n'
DOUBLE:        .DATA.L B'10000000000000000000000000000000
DATA_BUF1:     .DATA.L _DATA_BUF
S_STATUS2:     .DATA.L _S_STATUS
IINV1:         .DATA.L I_INV
TSTATUS_:      .DATA.L _T_STATUS
USTATUS4:      .DATA.L _U_STATUS
        .ALIGN 4

;*********************
; NOT PROGRAM MODE
;*********************
NOT_PRG:
        MOV P_STATUS0,R1
        MOV.B @R1,R0
        TST #B'1,R0
        BT  ANALOG
	BRA K_SET
	NOP
ANALOG:
        MOV AD_DAT,R1
        MOV.W @R1,R1		;GET DATA OF A/D

	TST #B'10,R0
        BT  VOLUME
	MOV V163,R2
	MOV V819,R3
	CMP/GT R2,R1
	BT  CHK_HI
	MOV R2,R1
CHK_HI:
	CMP/GT R1,R3
	BT  VDC10
	MOV R3,R1
VDC10:
	SUB R2,R1
	MOV BIT10,R4
	MULS R1,R4
	STS MACL,R1
	MOV V656,R5
	DIVS R5,R1
	
VOLUME:
;        MOV FMAX,R2
	MOV FSAT,R2
        MOV.W @R2,R2		;GET FSAT

	MOV RATIO,R5
	MOV.W @R5,R5		;GET RATIO OF ANALOG COMMAND
	MULS R2,R5
	STS MACL,R2
	MOV #100,R7
	DIVS R7,R2		;R2=FSAT WHICH IS MULTIPLIED RATIO OF ANALOG COMMAND

	MOV R2,R7		;STORE FSAT TO R7
	MOV FBIAS,R8
	MOV.W @R8,R8		;GET FBIAS
	MULS R5,R8
	STS MACL,R8
	MOV #100,R9
	DIVS R9,R8		;R8=FBIAS WHICH IS MULTIPLIED RATIO OF ANALOG COMMAND
	MOV R8,R6
	SUB R8,R2		;R2=FSAT-FBIAS

        MOV BIT10,R3		;GET 1024(10BIT)
        MULS R2,R1
        STS MACL,R10
        DIVS R3,R10		;R10=(AD_DATA*(FSAT-FBIAS))/1024

	ADD R6,R10		;R10=[{AD_DATA*(FSAT-FBIAS)}/1024]+FBIAS

	CMP/GT R7,R10		;IF R10 > FSAT
	BF GO_CON		;THEN IGNOR
	MOV R7,R10		;ELSE STORE FSAT TO R10
GO_CON:
        MOV FSAT,R3
        MOV.W @R3,R3
        CMP/GT R3,R10
        BF GO_CON1
        MOV R3,R10
GO_CON1:

        TST #B'100000,R0
	BF K_SET           ;IF DCEL TO STP NOT UPDATE FSET(IT IS SETTED TO 0 BF)
;VOLUME1---------------BEGIN------------------------
        MOV WSTATUS5,R1
        MOV.B @R1,R0
        TST #B'1000,R0          ;IF SEARCH SPEED
        BF K_SET                ;THEN NOT UPDATE FSET(FLAST)
;VOLUME1----------------END-------------------------
        MOV FLAST1_,R1
        MOV.W R10,@R1		;STORE R10 TO FLAST

	MOV FRE_RPM1,R14
	JSR @R14;FRE_TO_RPM
	NOP
        MOV RPMLAST1_,R0
	MOV.W R1,@R0
        MOV MCLAST1_,R0
        MOV.L R2,@R0

K_SET:  
        MOV SYSFLG1_,R1
        MOV.B @R1,R0
        TST #B'100,R0        ;TEST SYSFLG.7 1=RUN-MODE 0=NO-RUN
        BF  N_SH_FSET
        BRA SH_FSET
        NOP
N_SH_FSET:
        MOV TSTATUS1_,R1
	MOV.B @R1,R0
	TST #B'1,R0
	BF  SH_FSET_B
        MOV DSP_SWP,R1
        MOV.W @R1,R0
        CMP/EQ #0,R0
        BT  SHOW_FR
        BRA SH_FSET
        NOP
SHOW_FR:
        MOV TSTATUS1_,R1
        MOV.B @R1,R0
        TST #B'10000,R0
        BT  SHOW_FR1
        MOV TUNE,R10
        MOV POINT01,R1
        MOV #5,R0
        MOV.B R0,@R1
        BRA SHOW_DBUF
        NOP
SHOW_FR1:
;        MOV USTATUS1,R1
;        MOV.B @R1,R0
;        TST #B'10,R0
;        BT  SHOW_FR2
;        MOV #0,R10
;        MOV #2,R2
;        BRA S_PT
;        NOP
;SHOW_FR2:

        MOV RSTATUS_,R0
	MOV.B @R0,R0
	TST #B'100000,R0
	BT  NOT_CHANGE
	MOV FRUN1,R1
	MOV #0,R0
	MOV.W R0,@R1
NOT_CHANGE:
;FLYINGA
MOV WSTATUS5,R1
MOV.B @R1,R0

;CORRECT2-------------------BEGIN----------------------
TST #B'10000000,R0
BF  SHOW_NORM
;CORRECT2--------------------END-----------------------

;FAST1----------BEGIN
TST #B'100000,R0
BT  SHOW_NORM
;FAST1-----------END
TST #B'1000,R0
BT SHOW_NORM
MOV FIND,R10
MOV POINT01,R1
MOV #5,R0
MOV.B R0,@R1
BRA SHOW_DBUF
NOP

SHOW_NORM:
;FLYINGA

	MOV DISP_TYPE,R1
	MOV.B @R1,R0
	CMP/EQ #0,R0
	BT  FREQ_SHOW
	CMP/EQ #1,R0
	BT  AMP_SHOW
	CMP/EQ #2,R0
	BT  RPM_SHOW
	MOV MCSPEED1,R1
        MOV.L @R1,R10
	MOV #5,R2
	BRA S_PT
	NOP
AMP_SHOW:
        MOV DIGTOG2,R1
        MOV #4,R2
        MOV.B R2,@R1
;FAST1------BEGIN-------
MOV WSTATUS5,R1
MOV.B @R1,R0
TST #B'100000,R0
BT  TWO_DECIMAL
;FAST1-------END--------
        MOV AMP,R1
        MOV @R1,R10
        MOV #1,R2
;FAST1------BEGIN-------
BRA S_PT
NOP
TWO_DECIMAL:
;FAST1--------END-------
MOV TEST_D,R1
MOV.L @R1,R10
MOV #2,R2
        BRA S_PT
	NOP
RPM_SHOW:
        MOV RPM1,R1
        MOV.W @R1,R10
        MOV #5,R2
        BRA S_PT
        NOP
FREQ_SHOW:
        MOV FRUN1,R1
        MOV.W @R1,R10

;MOV TEST_D,R1
;MOV.W @R1,R10
;MOV #1,R2
;BRA S_PT
;NOP
	
;SHAR R10
;MOV R10,R0
;SHAL R0
;BF NO_NEG
;NEG R10,R10
;NO_NEG:
;BRA SHOW
;NOP
	;MOV #50,R0
	;CMP/GE R0,R10
	;BT SHOW
	;MOV #0,R10 
        BRA SHOW
        NOP

SH_FSET_B:
	MOV DISP_TB,R1
	MOV.B @R1,R0
	MOV #1,R1
	CMP/GT R1,R0
	BF  FREQ_SHOW1_B
	CMP/EQ #2,R0
	BT  RPM_SHOW1_B
	MOV MC_BACK,R1
        MOV.L @R1,R10
	MOV #5,R2
	BRA S_PT
	NOP
RPM_SHOW1_B:
	MOV RPM_BACK,R1
	MOV.W @R1,R10
	MOV #5,R2
	BRA S_PT
	NOP
FREQ_SHOW1_B:
        MOV FSET_BACK,R1
        MOV.W @R1,R10
	BRA SHOW
	NOP

        .ALIGN 4
V163:     .DATA.L 163
V656:     .DATA.L 656
V819:     .DATA.L 819
AD_DAT:   .DATA.L _AD_DAT
WSTATUS5:  .DATA.L _W_STATUS
BIT10:   .DATA.L 1024
P_STATUS0: .DATA.L _P_STATUS
RATIO:     .DATA.L _RATIO
FSAT:      .DATA.L _F_SAT
FIND:      .DATA.L B'01111001011010000100000000101110
FBIAS:     .DATA.L _F_BIAS
FRE_RPM1:  .DATA.L FRE_TO_RPM
DSP_SWP:   .DATA.L DISP_SWAP
MCSPEED1:  .DATA.L MC_SPEED
AMP:       .DATA.L AMPERE
RPM1:      .DATA.L _RPM
RSTATUS_:  .DATA.L _R_STATUS
FLAST1_:   .DATA.L FLAST
MCLAST1_:  .DATA.L MC_LAST
RPMLAST1_: .DATA.L _RPM_LAST
SYSFLG1_:  .DATA.L SYSFLG
TSTATUS1_: .DATA.L _T_STATUS
        .ALIGN 4


SH_FSET:
                MOV PAHI,R1
                MOV.B @R1,R0
                TST #B'1000000,R0
                BF  NO_OH
                MOV OHCOUNT,R1
                MOV.B @R1,R0
                ADD #1,R0
                MOV.B R0,@R1
                MOV #100,R2             ;OC => OH WHEN TIME OVER 0.1 S.
                CMP/GE R2,R0
                BF  NO_OH
                MOV.B R2,@R1
                MOV OH_T1,R10           ;ELSE SHOW LU(NOT OUT FAULT CONTACT)
                MOV POINT01,R1
                MOV #5,R0
                MOV.B R0,@R1
                BRA SHOW_DBUF
                NOP

NO_OH:
                MOV V_DCI,R0            ;CHECK LU IN STP MODE
                MOV @R0,R0
                MOV LU_REF,R1
                CMP/GT R1,R0            ;IF VDC > LU_REF
                BT  NO_LU               ;THEN NO_LU
;SETKEY-----------------BEGIN-----------------------------
        MOV TSTATUS,R1
        MOV.B @R1,R0
        TST #B'10,R0
        BF  OUT_NA_JA1
        OR  #B'10,R0
	MOV.B R0,@R1
        MOV FLAST1,R1
        MOV.W @R1,R10
        MOV #104,R11            ;WRITE FLAST WHEN LU IN STOP MODE
        MOV EEWRITE1_,R14        ;TO EEPROM
	JSR @R14;EE_WR
	NOP
OUT_NA_JA1:
;SETKEY------------------END------------------------------
                MOV LU_T1,R10           ;ELSE SHOW LU(NOT OUT FAULT CONTACT)
                MOV POINT01,R1
                MOV #5,R0
                MOV.B R0,@R1
                BRA SHOW_DBUF
                NOP
NO_LU:


;	MOV DISP_TYPE,R1
	MOV DISP_TB,R1
	MOV.B @R1,R0
	MOV #1,R1
	CMP/GT R1,R0
	BF  FREQ_SHOW1
	CMP/EQ #2,R0
	BT  RPM_SHOW1
	MOV MCLAST1,R1
        MOV.L @R1,R10
	MOV #5,R2
	BRA S_PT
	NOP
RPM_SHOW1:
        MOV RPMLAST1,R1
        MOV.W @R1,R10
        MOV #5,R2
        BRA S_PT
        NOP
FREQ_SHOW1:
       MOV FLAST1,R1
       MOV.W @R1,R10

;MOV #0,R10          ;READ EE
;MOV #53,R11
;MOV RDEEPR,R14
;JSR @R14
;NOP

;MOV TEST_D,R1
;MOV.W @R1,R10
;MOV #2,R2
;BRA S_PT
;NOP
SHOW:

;******************************************
; DATA THAT DO U WANT TO TEST
; U MUST DEFINE ITS ADDRESS AT THE BUTTOM
;******************************************
;MOV TEST_D,R1
;MOV.B @R1,R10
;MOV SCALE_M,R1
;MULS R10,R1
;STS MACL,R10
;MOV SCALE_D,R1
;DIVS R1,R10
;*******************************
        MOV MFF,R0
        AND R0,R10
        MOV GT1000,R0
        CMP/GE R0,R10
        BT  POINT_1
        MOV #2,R2
        BRA S_PT
        NOP
POINT_1:MOV #1,R2
S_PT:
        MOV DISP_TYPE,R1
        MOV.B @R1,R0
        CMP/EQ #3,R0
        BF  NOT_MC_DISP
        MOV GT1000,R0
        CMP/GE R0,R10
        BT  NOT_MC_DISP
        MOV #1,R2
NOT_MC_DISP:
        MOV POINT01,R1
        MOV.B R2,@R1

        MOV DISP_B,R1
;        MOV @R1,R0
;        CMP/EQ R0,R10
;        BT  SS1
        MOV R10,@R1
	MOV SHOWR10,R13
        JSR @R13;SHOW_R10_D
        NOP
SHOW_DBUF:
        MOV DATA_BUF1_,R11
        MOV R10,@R11

        MOV SYSFLG1,R0
        MOV.B @R0,R0
        TST #B'10,R0                    ;IF NOT P_MODE
        BT SS1                          ;THEN SS1
        MOV USTATUS1,R0
        MOV.B @R0,R0
        TST #B'100000,R0                ;IF P_MODE AND WATING FOR KEY DATA
        BF CHK_POINT                    ;THEN CHK_POINT
        MOV SSTATUS2,R0
        MOV.B @R0,R0
        TST #B'1000,R0
        BF NOR_MAL
        MOV TSTATUS,R0
        MOV.B @R0,R0
        TST #B'10000000,R0
        BF  NOR_MAL
        MOV USTATUS1,R0
        MOV.B @R0,R0
        TST #B'1,R0
        BF  NOR_MAL

        ADD #2,R11                      ;ELSE MASK DIGIT 4,3 WITH F-
        MOV #B'000001000,R0
        MOV.B R0,@R11
        ADD #1,R11
        MOV #B'00101110,R0
        MOV.B R0,@R11
        MOV POINT01,R1
        MOV #5,R0
        MOV.B R0,@R1
        BRA NOR_MAL
        NOP

CHK_POINT:
        MOV PROGADD2,R1
        MOV.B @R1,R1
        MOV #25,R0
        CMP/GE R0,R1                    ;IF FN IS IN RANGE OF 10-14
        BF  NO_POINT                    ;THEN ONE POINT DECIMAL
        MOV #37,R0                      ;ELSE NO POINT
        CMP/GT R0,R1
        BT  CHK2POINT
        MOV POINT01,R1
        MOV #1,R0
        MOV.B R0,@R1
        MOV PROG_DAT1,R1
        MOV.W @R1,R0
        MOV #100,R1
        CMP/GE R1,R0
        BF  MASKD43
        MOV T1000,R1
        CMP/GE R1,R0
        BT  OVER1000
        ADD #3,R11
        MOV #0,R0
        MOV.B R0,@R11
        BRA SS1
        NOP
OVER1000:
        MOV T10000,R1
        CMP/GE R1,R0
        BF  SS1
        MOV POINT01,R1
        MOV #5,R0
        MOV.B R0,@R1
        BRA SS1
        NOP

CHK2POINT:
        MOV #53,R0                      ;ELSE NO POINT
        CMP/GT R0,R1
        BT  NO_POINT
        MOV POINT01,R1
        MOV #2,R0
        MOV.B R0,@R1
        MOV PROG_DAT1,R1
        MOV.W @R1,R0
        MOV T1000,R1
        CMP/GE R1,R0
        BF  MASKD4
        MOV T10000,R1
        CMP/GE R1,R0
        BF  SS1
        MOV POINT01,R1
        MOV #1,R0
        MOV.B R0,@R1
        BRA SS1
        NOP

NO_POINT:
        MOV POINT01,R1
        MOV #5,R0
        MOV.B R0,@R1

        MOV PROG_DAT1,R1
        MOV.W @R1,R0
        MOV #10,R1
        CMP/GE R1,R0
        BT  CHK_MASKD43
        ADD #1,R11
        MOV #0,R0
        MOV.B R0,@R11
        ADD #1,R11
        MOV.W R0,@R11
        BRA SS1
        NOP
CHK_MASKD43:
        MOV #100,R1
        CMP/GE R1,R0
        BF  MASKD43
        MOV T1000,R1
        CMP/GE R1,R0
        BT  SS1

MASKD4: ADD #3,R11
        MOV #0,R0
        MOV.B R0,@R11
        BRA SS1
        NOP

MASKD43:
        ADD #2,R11
        MOV #0,R0
        MOV.W R0,@R11
SS1:
        MOV DIGTOG2,R0
        MOV.B @R0,R0
        CMP/EQ #4,R0
        BT  NOR_MAL
        MOV DATA_BUF1_,R11
        MOV R10,@R11
NOR_MAL:

        MOV SCAN3,R14
        JSR @R14;SCAN
        NOP
        MOV KEY1,R10
        JSR @R10;KEYPROC
        NOP
;FLYINGA
MOV VDC1,R0
MOV @R0,R0
MOV LU_REF,R1
CMP/GT R0,R1                    ;IF LU_REF > VDC
BT  OFF_MAG
MOV PBD_HI,R1
MOV.B @R1,R0
TST #B'1000000,R0
BT  MAG_ON1                     ;CORRECT1
MOV TIME2000,R2
MOV TIME_D,R1
MOV.W @R1,R0
CMP/GE R2,R0
BT  MAG_ON
ADD #1,R0
MOV.W R0,@R1
BRA SS2
NOP
OFF_MAG:
MOV PBD_HI,R1
MOV.B @R1,R0
OR  #B'1000000,R0               ;OFF MAG
MOV.B R0,@R1
MOV TIME_D,R1
MOV #0,R0                       ;CLEAR TIME DELAY
MOV.W R0,@R1
BRA SS2
NOP
MAG_ON:
MOV PBD_HI,R1
MOV.B @R1,R0
AND #B'10111111,R0               ;ON MAG
MOV.B R0,@R1
;CORRECT1----------------BEGIN------------------------------------
MOV WSTATUS2,R1
MOV.B @R1,R0
OR  #B'1000000,R0
MOV.B R0,@R1
;CORRECT1-----------------END-------------------------------------
MAG_ON1:                         ;CORRECT1
;FLYINGA

	MOV SYSFLG1,R2
	MOV.B @R2,R0
	TST #B'1000,R0			;IF NOT IN TRIP MODE 
	BT  SS2				;THEN GO TO SS2
	MOV TIP_TYP0,R0			
	MOV.B @R0,R0
	MOV #4,R1			;TIP_TYPE #4=LU
	CMP/EQ R1,R0			;IF NOT LU
	BF  SS2				;THEN GO TO SS2
	MOV Q_STATUS,R5
	MOV.B @R5,R0
	TST #B'1000000,R0		;IF USER SELECT AUTO-RESTART
	BT  SS2				;THEN GO TO SS2
	MOV VDC1,R0
	MOV @R0,R0
	MOV LU_REF,R1
	CMP/GT R0,R1			;IF LU_REF > VDC
	BT  SS2				;THEN GO TO SS2
	MOV RE_COUNT,R3		
	MOV @R3,R0			;R3 = COUNTER OF AUTO-RESTART
	ADD #1,R0			;COUNT EVERY LOOP OF 1 ms
	MOV R0,@R3
	MOV RE_TIME,R1
	MOV.W @R1,R1			;R1=RESTART TIME(IN SEC.) 
	MOV S1000,R4			;SCALE SEC. TO msec.
	MULS R4,R1
	STS MACL,R1
	CMP/GE R1,R0			;IF COUNTER < RESTART TIME
	BF  SS2				;THEN GO TO SS2
;FLYINGA
MOV P_STATUS,R1
MOV.B @R1,R0
TST #B'100,R0           ;IF RUN BY KEYPAD
BT  NOT_SEARCH          ;THEN NOT_SEARCH
MOV INP3,R1             ;ELSE CHECK FWD_RWD CONTINUE
MOV.W @R1,R0
AND #B'00110000,R0
TST #B'00100000,R0      ;IF FWD SIGNAL IN
BT  REVERSE             ;THEN CHK REVERSE CONTINUE
TST #B'00010000,R0      ;ELSE IF RWD SIGNAL IN(BOTH FWD & REW IN)
BF  NOT_SEARCH          ;THEN NOT_SEARCH
BRA SET_SEARCH          ;ELSE SET SEARCH FLG.
NOP
REVERSE:
TST #B'00010000,R0      ;IF REW SIGNAL NOT IN(BOTH FWD & REW NOT IN)
BT  NOT_SEARCH          ;THEN NOT_SEARCH

SET_SEARCH:
MOV VSTATUS5,R1
MOV.B @R1,R0
OR  #B'10000,R0         ;SET SEARCH FLG.
MOV.B R0,@R1
BRA NOT_SEARCH1
NOP
NOT_SEARCH:
MOV WSTATUS2,R1
MOV.B @R1,R0
TST #B'1,R0                ;IF USER SELECT FN-22 = "1"
BF  NOT_SEARCH1            ;THEN NOT_SEARCH1(NOT CLEAR FLG.)
MOV VSTATUS5,R1
MOV.B @R1,R0
AND #B'11101111,R0         ;SET SEARCH FLG.
MOV.B R0,@R1
NOT_SEARCH1:
;FLYINGA

        MOV #0,R1                       ;ELSE RESET COUNTER
	MOV R1,@R3
	MOV.B @R2,R0
        AND #B'11010010,R0              ;SET BLINK,TRIP AND RUN FLAG(FLYINGA)
        MOV.B R0,@R2
;FLYINGA
        MOV P_STATUS,R1
        MOV.B @R1,R0
        AND #B'11001111,R0              ;CLEAR FIRST RUN,DEC.TO STP FLAG
        MOV.B R0,@R1
;FLYINGA

        MOV DATA_BUF1_,R1
	ADD #4,R1
	MOV.B @R1,R0
	AND #B'10111111,R0		;TURN OFF RUN-LED
	OR #B'00100000,R0		;ON STOP-LED
	MOV.B R0,@R1

         MOV PBHI,R1                     ;INT ROM
         MOV.B @R1,R0
         OR #B'10000000,R0               ;OFF OPTO DRIVE
         MOV.B R0,@R1

        MOV PBDR_L,R1                  ;INT ROM
        MOV.B @R1,R0
        OR #B'00000010,R0              ;RESET FAULT CONTACT
        MOV.B R0,@R1

;        MOV PAHI,R1
;        MOV.B @R1,R0                    ;EXT ROM
;        AND #B'01111111,R0              ;OFF OPTO DRIVE
;        MOV.B R0,@R1

;        MOV PADR_L,R1
;        MOV.B @R1,R0                    ;EXT ROM
;        OR #B'00000010,R0               ;RESET FAULT CONTACT
;        MOV.B R0,@R1
;-----------CLEAR COUNTER OF S_CURVE WHEN AUTO RESTART---------------
	MOV #0,R10
	MOV A_INCREA,R0
	MOV R10,@R0
	MOV A_MSEC10,R0
	MOV R10,@R0
	MOV A_INCREA2,R0
	MOV R10,@R0
	MOV A_MSEC102,R0
	MOV R10,@R0
	MOV A_INCREA3,R0
	MOV R10,@R0
	MOV A_MSEC103,R0
	MOV R10,@R0
	MOV DE_INCREA,R0
	MOV R10,@R0
	MOV DE_MSEC10,R0
	MOV R10,@R0
	MOV DE_INCREA2,R0
	MOV R10,@R0
	MOV DE_MSEC102,R0
	MOV R10,@R0
	MOV DE_INCREA3,R0
	MOV R10,@R0
	MOV DE_MSEC103,R0
	MOV R10,@R0
;------------------------------------------------------------------------
;FLYINGA
MOV BRK_C_STR,R0
MOV.W R10,@R0
;FLYINGA

        MOV.B @R5,R0
	TST #B'10000000,R0	;IF USER WANT RESTART AT STARTING FREQ.
	BT SS2			;THEN GO TO SS2  
	MOV FRUN1,R1		;ELSE STORE STARTING FREQ. WITH FSET
	MOV.W @R1,R1
	MOV STRFREQ1,R2
	MOV.W R1,@R2
	BRA SS3
	NOP	
SS2:
	MOV STRFREQ1,R1
	MOV STRFREQ2,R2		;GET SPARE STARTING FREQ.
	MOV.W @R2,R2
	MOV.W R2,@R1		;STORE NORMAL STARTING FREQ.
SS3:
        LDS.L @SP+,PR
        RTS
        NOP

	.ALIGN 4
DATA_BUF1_:.DATA.L _DATA_BUF
DISP_TYPE: .DATA.L _DISP_TYPE
FLAST1:  .DATA.L FLAST
RPMLAST1:  .DATA.L _RPM_LAST
MCLAST1:   .DATA.L MC_LAST
TUNE:      .DATA.L B'00111110011010000111000000111100
POINT01:   .DATA.L POINT
FRUN1:     .DATA.L FRUN
FSET_BACK:.DATA.L FSET_B
MC_BACK: .DATA.L _MC_BACK
RPM_BACK: .DATA.L _RPM_BACK
FMAX:    .DATA.L _F_MAX
TSTATUS:   .DATA.L _T_STATUS
SYSFLG1:  .DATA.L SYSFLG
P_STATUS: .DATA.L _P_STATUS
EEWRITE1_:.DATA.L EE_WR
TEST_D:  .DATA.L _FIL_AMP
PADR_L:   .DATA.L H'5FFFFC1
PBDR_L:   .DATA.L H'5FFFFC3
PBHI:   .DATA.L H'5FFFFC2
;V163:   .DATA.L 163
;V656:   .DATA.L 656
;V819:   .DATA.L 819
DISP_TB:   .DATA.L _DISP_TB
DIGTOG2:   .DATA.L _DIG_TOG
TIP_TYP0:  .DATA.L TIP_TYP
LU_T1:     .DATA.L B'00000000011101010011010000000000
OH_T1:     .DATA.L B'00000000011011010111011100000000
USTATUS1:  .DATA.L _U_STATUS
PAHI:      .DATA.L H'5FFFFC0
KEY1:      .DATA.L KEYPROC
SCAN3:     .DATA.L SCAN
SHOWR10:   .DATA.L SHOW_R10_D
PROG_DAT1:
         .DATA.L PROG_DAT
PROG_ADD1:
         .DATA.L PROG_ADD
NOT_SHOW:.DATA.L N_SHOW
INPORT1: .DATA.L INPORT
GT1000:  .DATA.L 10000
MFF:     .DATA.L H'FFFF
DISP_B:  .DATA.L DISP_BAK
SETA1:   .DATA.L _SETA
RO_POS1: .DATA.L _RPOS_1;
RO_POS2: .DATA.L _RPOS_2;
RO_POS3: .DATA.L _RPOS_3;
RO_POS4: .DATA.L _RPOS_4;
SCALE_M: .DATA.L 5000
SCALE_D: .DATA.L 32765
HZ50:    .DATA.L 5000
Q_STATUS:.DATA.L _Q_STATUS
SSTATUS2: .DATA.L _S_STATUS
PROGADD2: .DATA.L PROG_ADD
T1000:    .DATA.L 1000
T10000:   .DATA.L 10000
AD_BAK:  .DATA.L _AD_BAK
AD_CNT:  .DATA.L _AD_CNT
W2F:     .DATA.L 20860
START_F1:.DATA.L START_F
STOP_F1: .DATA.L STOP_F
R11_STATUS:
         .DATA.L R11_STUS
WM_:	 .DATA.L _WM
SETWM:   .DATA.L 3000
SET_WM1: .DATA.L SET_WM
CONT:    .DATA.L 16000
COUNT:	 .DATA.L _COUNT
OHCOUNT:   .DATA.L _OH_COUNT
VDC1:    .DATA.L _V_DC
LU_REF:  .DATA.L 1408;1493;1665;1570
S1000:	 .DATA.L 1000
RE_COUNT:.DATA.L _RE_COUNT
RE_TIME: .DATA.L _RE_TIME
STRFREQ1: .DATA.L _STR_FRE
STRFREQ2: .DATA.L _STR_FRE2
A_INCREA: .DATA.L INCREA_
A_INCREA2:.DATA.L INCREA2_
A_INCREA3:.DATA.L INCREA3_
A_MSEC10: .DATA.L MSEC10_
A_MSEC102:.DATA.L MSEC102_
A_MSEC103:.DATA.L MSEC103_
DE_INCREA: .DATA.L D_INCREA_
DE_INCREA2:.DATA.L D_INCREA2_
DE_INCREA3:.DATA.L D_INCREA3_
DE_MSEC10: .DATA.L D_MSEC10_
DE_MSEC102:.DATA.L D_MSEC102_
DE_MSEC103:.DATA.L D_MSEC103_
;DISP_TYPE: .DATA.L _DISP_TYPE
V_DCI:     .DATA.L _V_DCIN
INP3:      .DATA.L INPORT
BRK_C_STR: .DATA.L _BRK_COUNT
WSTATUS2:  .DATA.L _W_STATUS
PBD_HI:    .DATA.L H'5FFFFC2
TIME2000:  .DATA.L 2000
TIME_D:    .DATA.L _TIME_D
VSTATUS5:  .DATA.L _V_STATUS
        .ALIGN 4
;*********************
; INT. 1mS TIME BASE
;*********************
LOOP: ;TIME BASE 1mS
        STS.L PR,@-SP
        MOV MSEC1,R1
        MOV.W @R1,R0
        ADD #1,R0                  ;INC MSEC   
        MOV MMSEC1,R5
        MOV.W @R5,R6
        ADD #1,R6
        MOV M1000,R2               ;CMP 1000 mS
        CMP/EQ R0,R2
        BF  NO1000MS              
        MOV #0,R0                  ;CLR MSEC
        MOV #0,R6                  ;CLR MMSEC
        MOV SEC1,R2                ;INC SEC
        MOV.W @R2,R3
        ADD #1,R3
        MOV S3600,R4               ;CMP 3600 S
        CMP/EQ R3,R4
        BF NO3600S
        MOV #0,R3                  ;CLR SEC
NO3600S:
        MOV.W R3,@R2               ;SAVE SEC
NO1000MS:
        MOV.W R0,@R1               ;SAVE MSEC
	MOV.W R6,@R5		   ;SAVE MMSEC

        MOV SYSFLG_2,R1
	MOV.B @R1,R0
	TST #B'1000,R0			;IF TRIP MODE
        BT  NOT_OUT_TRIP                ;THEN OUT_LOOP(NOT CHECK CONTINUE)
        BRA OUT_TRIP
        NOP
        .ALIGN 4
SEC1:    .DATA.L SEC
MSEC1:   .DATA.L MSEC
MMSEC1:  .DATA.L MMSEC
S3600:   .DATA.L 3600
M1000:   .DATA.L 1000
SYSFLG_2: .DATA.L SYSFLG
        .ALIGN 4
NOT_OUT_TRIP:

;        .INCLUDE "TUNNING.H"
        MOV TUN_NING,R14
        JSR @R14;TUNNING
        NOP

        MOV S_STATUS3,R1
	MOV.B @R1,R0
	TST #B'10000,R0
	BT  NOT_UP_DOWN
	BRA UP_DOWN
	NOP
NOT_UP_DOWN:

	MOV PS_TATUS,R1
	MOV.B @R1,R0
	TST #B'100,R0
	BF  CHK_EXT                       ;EXT ST/STP JMP CONT

	MOV SYSFLG_0,R1
	MOV.B @R1,R0
	TST #B'100,R0
	BF  BY_KEY                        ;RUN MODE JMP CONT
	MOV PS_TATUS,R1
	MOV.B @R1,R0
	TST #B'10000,R0
	BF  BY_KEY                        ;EXT ST/STP JMP CONT
	MOV FRUN0,R1
	MOV #0,R2
	MOV.W R2,@R1

OUT_TRIP:
        MOV OUTLOOP_,R14
        JMP @R14;OUTLOOP
	NOP
CHK_EXT:
	BRA EXTERNAL
	NOP
BY_KEY:
;IMPROVE3
        MOV INP_HI,R1
	MOV.B @R1,R0		;INPORT HIGH BYTE OF EXTERNAL(FOR JOG CHECKING)
        TST #B'100000,R0        ;TEST JOG(0 OR 1)
        BF  NOT_JOG_IN          ;IF JOG IN(JOG=0) THEN JMP TO JOG
        BRA JOG
        NOP
NOT_JOG_IN:
	MOV QSTATUS1,R1
	MOV.B @R1,R2
	MOV #B'11111011,R3
	AND R3,R2
        MOV.B R2,@R1            ;CLEAR JOG FLAG
;IMPROVE3

	MOV FLAST2_,R1
	MOV.W @R1,R0
	MOV FSET1_,R1
	MOV.W R0,@R1

	MOV RSTATUS4,R1
	MOV.B @R1,R0
	AND #B'01111111,R0	;CLEAR EXT.SPEED FLAG WHEN STR/STP BY KEY
	MOV.B R0,@R1
	BRA KEY_EXT
	NOP

        .ALIGN 4
OUTLOOP_: .DATA.L OUTLOOP
SYSFLG_0: .DATA.L SYSFLG
FRUN0:    .DATA.L FRUN
PS_TATUS: .DATA.L _P_STATUS
RSTATUS4: .DATA.L _R_STATUS
S_STATUS3:.DATA.L _S_STATUS
FSET1_:	  .DATA.L FSET
FLAST2_:  .DATA.L FLAST
TUN_NING: .DATA.L TUNNING
        .ALIGN 4
EXTERNAL:   
	 .INCLUDE "VARY.H"
	BRA KEY_EXT
	NOP
UP_DOWN:
;IMPROVE3
        MOV INP_HI1,R1
	MOV.B @R1,R0		;INPORT HIGH BYTE OF EXTERNAL(FOR JOG CHECKING)
        TST #B'100000,R0        ;TEST JOG(0 OR 1)
        BF  NOT_JOG_IN1         ;IF JOG IN(JOG=0) THEN JMP TO JOG

        MOV S_STATUS4,R1
        MOV.B @R1,R0
        AND #B'11011111,R0
        MOV.B R0,@R1
        BRA JOG
        NOP
NOT_JOG_IN1:
        MOV QSTATUS1_,R1
	MOV.B @R1,R2
	MOV #B'11111011,R3
	AND R3,R2
        MOV.B R2,@R1            ;CLEAR JOG FLAG
;IMPROVE3

         .INCLUDE "UP_DOWN.H"
KEY_EXT:
	MOV STRFREQ3,R4
	MOV.W @R4,R4
	MOV FSET_5,R1	
	MOV.W @R1,R0
	CMP/GE R4,R0		;IF FSET < START FREQ 
	BF  NOT_CHK		;THEN NOT CHECK LOWER UPPER & JUMP FREQ.

	MOV #0,R6
	MOV FJUMP1,R2
	MOV.W @R2,R2
	MOV #0,R9
	CMP/EQ R9,R2		;IF JUMP FRE=0 
	BT  NO_JUMP1		;THEN JUMP1 NOT ACTIVE
	MOV R2,R3		;R2=R3=JUMP FREQ.1
	MOV #50,R8
	SUB R8,R2		;R2=MIN. BOUNDARY
	ADD #50,R3		;R3=MAX. BOUNDARY
	CMP/GT R2,R0
	BF NO_JUMP1
	CMP/GT R0,R3
	BF NO_JUMP1
	MOV.W R2,@R1
	MOV SSTATUS1,R5
	MOV.B @R5,R0
	OR #B'1,R0
	MOV.B R0,@R5	
	BRA CHK_JUMP2
	NOP
NO_JUMP1:
	ADD #1,R6
CHK_JUMP2:
	MOV.W @R1,R0
	MOV FJUMP2,R2
	MOV.W @R2,R2
	CMP/EQ R9,R2		;IF JUMP2 = 0 
	BT  NO_JUMP2		;THEN JUMP2 NOT ACTIVE
	MOV R2,R3		;R2=R3=JUMP FREQ.2
	MOV #50,R8
	SUB R8,R2		;R2=MIN. BOUNDARY
	ADD #50,R3		;R3=MAX. BOUNDARY
	CMP/GT R2,R0
	BF NO_JUMP2
	CMP/GT R0,R3
	BF NO_JUMP2
	MOV.W R2,@R1
	MOV SSTATUS1,R5
	MOV.B @R5,R0
	OR #B'1,R0
	MOV.B R0,@R5	
	BRA CHK_JUMP3
	NOP
NO_JUMP2:
	ADD #1,R6
CHK_JUMP3:
	MOV.W @R1,R0
	MOV FJUMP3,R2
	MOV.W @R2,R2
	CMP/EQ R9,R2		;IF JUMP3 = 0 
	BT NO_JUMP3		;THEN JUMP3 NOT ACTIVE
	MOV R2,R3		;R2=R3=JUMP FREQ.3
	MOV #50,R8
	SUB R8,R2		;R2=MIN. BOUNDARY
	ADD #50,R3		;R3=MAX. BOUNDARY
	CMP/GT R2,R0
	BF NO_JUMP3
	CMP/GT R0,R3
	BF NO_JUMP3
	MOV.W R2,@R1
	MOV SSTATUS1,R5
	MOV.B @R5,R0
	OR #B'1,R0
	MOV.B R0,@R5	
	BRA CHK_UP_LOW
	NOP
NO_JUMP3:
	ADD #1,R6
CHK_UP_LOW:
	MOV #3,R0
	CMP/EQ R0,R6
	BF  CHK_UP_LOW1
	MOV SSTATUS1,R5
	MOV.B @R5,R0
	AND #B'11111110,R0	;CLEAR FLAG OF JUMP FREQ.
	MOV.B R0,@R5
CHK_UP_LOW1:
	MOV.W @R1,R0
	MOV UPPER,R2
	MOV.W @R2,R2
	CMP/GE R0,R2		;IF FSET < UPPER
	BT LOW_CHK		;THEN CHECK LOWER
	MOV.W R2,@R1		;ELSE STORE UPPER TO FSET
	MOV QSTATUS4,R1
	MOV.B @R1,R0
	AND #B'11011111,R0	;SET UPPER LIMIT FLAG(OR CLEAR LOWER)
	MOV.B R0,@R1
	BRA NOT_CHK
	NOP
	.ALIGN 4
STRFREQ3:	.DATA.L _STR_FRE
FJUMP1:		.DATA.L _F_JUMP1
FJUMP2:		.DATA.L _F_JUMP2
FJUMP3:		.DATA.L _F_JUMP3
FSET_5:		.DATA.L FSET
SSTATUS1:	.DATA.L _S_STATUS
UPPER:		.DATA.L _UPPER
QSTATUS4:	.DATA.L _Q_STATUS
	.ALIGN 4
LOW_CHK:
	MOV LOWER,R3
	MOV.W @R3,R3
	CMP/GE R0,R3		;IF FSET < LOWER
	BF NOT_CHK
	MOV.W R3,@R1		;THEN STORE LOWER TO FSET
        MOV QSTATUS4_2,R1
	MOV.B @R1,R0
	OR #B'100000,R0		;SET LOWER LIMIT FLAG
	MOV.B R0,@R1
NOT_CHK:

        .INCLUDE "EXT.H"

;        MOV FLGSYS,R1
;        ADD #1,R1
;        MOV.B @R1,R0
;        TST #B'10,R0
;        BF  SENSORL
;        TST #B'100,R0           ;IF CONTROL METHOD IS NOT V/F
;        BT  NOT_VF              ;THEN NOT_VF
;SENSORL:
;        MOV RSTA1,R1
;        MOV.B @R1,R0
;        TST #B'100000,R0        ;IF DC BREAK FLAG SET
;        BF  NOT_VF              ;THEN NOT_VF
;        MOV STFREQ,R1
;        MOV.W @R1,R1
;        MOV FREQRUN1,R2
;        MOV.W @R2,R2
;        CMP/GT R1,R2            ;IF FRUN > START FREQ
;        BT  NOT_VF              ;THEN NOT_VF
;        MOV FSET1,R3
;        MOV.W @R3,R3
;        CMP/EQ R3,R1            ;IF FSET=START FREQ
;        BT  NOT_VF              ;THEN NOT_VF

;       MOV PA,R1                ;ELSE OFF OPTO
;       MOV.B @R1,R0
;       AND #B'01111111,R0
;       MOV.B R0,@R1

;       MOV CS1,R2
;       MOV R2,@R2          ;CS1 ACTIVE

;        MOV T_STATUS,R1
;        MOV.B @R1,R0
;        OR  #B'100000,R0        ;SET FLAG
;        MOV.B R0,@R1

;        BRA OUT_EXT_EXT
;        NOP
;NOT_VF:

;       MOV PA,R1
;       MOV.B @R1,R0
;       OR  #B'10000000,R0           ;ON OPTO
;       MOV.B R0,@R1

;       MOV CS1,R2
;       MOV R2,@R2                   ;CS1 ACTIVE

;        MOV T_STATUS,R1
;        MOV.B @R1,R0
;        AND #B'11011111,R0          ;CLEAR FLAG
;        MOV.B R0,@R1
;OUT_EXT_EXT:

;---------CHECK START FREQUENCY SIGNAL FOR CONTROL BREAK----
;       MOV FRUN2,R0                 
;       MOV.W @R0,R0
;       CMP/EQ #0,R0                 ;IF FRUN = 0
;       BT  OFF_SST                  ;JMP OFF SST
;	MOV PBDRH,R10
;       MOV.B @R10,R0
;       AND #B'01111111,R0
;       MOV.B R0,@R10                ;ON SST
;	BRA FOLLOW
;	NOP
;OFF_SST:
;	MOV PBDRH,R10
;        MOV.B @R10,R0
;        OR #B'10000000,R0
;        MOV.B R0,@R10                ;OFF SST
;---------END OF CHECK FREQUENCY SIGNAL FOR CONTROL BREAK----
FOLLOW:
        MOV PSTATUS_2,R1
        MOV.B @R1,R0
        TST #B'100000,R0	  	;check stop mode
        BT CON			;if user press stp-key then CLEAR FSET
        MOV FSET1,R1
	MOV #0,R0		
	MOV.W R0,@R1

        MOV USTATUS2,R1
        MOV.B @R1,R0
        TST #B'10,R0            ;IF FREE RUN STILL IN
        BT  NOT_FR
        AND #B'11111101,R0      ;THEN CLEAR FREE RUN FLG
        MOV.B R0,@R1
        MOV FREQRUN1,R1         ;SET FRUN = 0
        MOV #0,R0
        MOV.W R0,@R1
NOT_FR:
        MOV TSTATUS2,R1
        MOV.B @R1,R0
        TST #B'1,R0
        BT  NOT_SET1
        AND #B'11111110,R0
        MOV.B R0,@R1
        MOV SYSFLG4,R1
        MOV.B @R1,R0
        OR #B'1,R0
        MOV.B R0,@R1
NOT_SET1:

;        MOV DISP_TYPE3,R2
;        MOV.B @R2,R0
;        CMP/EQ #1,R0
;        BF CON
;        MOV DISP_TB3,R1
;        MOV.B @R1,R0
;        CMP/EQ #2,R0
;        BT RPM_DISPLAY
;        CMP/EQ #3,R0
;        BT MC_DISPLAY
;        MOV #0,R0
;        MOV.B R0,@R2
;        MOV DATA_B3,R1
;        ADD #4,R1
;        MOV.B @R1,R0
;        OR  #B'00000100,R0
;        AND #B'11100111,R0
;        MOV.B R0,@R1
;        BRA CON
;        NOP
;RPM_DISPLAY:
;        MOV.B R0,@R2
;        BRA CON1
;        NOP
;MC_DISPLAY:
;        MOV.B R0,@R2
;CON1:
;        MOV DATA_B3,R1
;        ADD #4,R1
;        MOV.B @R1,R0
;        OR  #B'00010000,R0
;        AND #B'11110011,R0
;        MOV.B R0,@R1
CON:
        MOV PSTATUS_2,R1
        MOV.B @R1,R0
	TST #B'10000,R0
	BT NOT_1ST_RUN
	AND #B'11101111,R0		;CLR 1ST RUN BIT
	MOV.B R0,@R1 
	BRA ACCDEC_PROC              ;IF FIRST RUN JMP 
	NOP

	 .ALIGN 4
FSET1:       .DATA.L FSET
;DISP_TB3:   .DATA.L _DISP_TB
;DISP_TYPE3: .DATA.L _DISP_TYPE
;DATA_B3:    .DATA.L _DATA_BUF
PSTATUS_2:   .DATA.L _P_STATUS
FLGSYS:      .DATA.L SYSFLG
STFREQ:      .DATA.L _STR_FRE
FREQRUN1:    .DATA.L FRUN
T_STATUS:    .DATA.L _T_STATUS
RSTA1:       .DATA.L _R_STATUS
USTATUS2:    .DATA.L _U_STATUS
        .ALIGN 4

NOT_1ST_RUN:
;        TST #B'100000,R0             ;IF DCT STP JMP
;        BF ACCDEC_PROC

        MOV FSET11,R0                 
        MOV.W @R0,R0
        CMP/EQ #0,R0                 ;ELSE IF FSET NOT 0
        BT  NOT_1ST_RUN2             ;JMP
        BRA ACCDEC_PROC
        NOP
NOT_1ST_RUN2:

        MOV FRUN2,R0                 
        MOV.W @R0,R0
        CMP/EQ #0,R0                 ;ELSE IF FRUN NOT 0
        BT  NOT_1ST_RUN3             ;JMP
        BRA ACCDEC_PROC
        NOP
NOT_1ST_RUN3:

	MOV RSTATUSB,R1
	MOV.B @R1,R0
        TST #B'100000,R0             ;ALTHOUGH FRUN=FSET=0,BUT IF THERE IS DC BREAK
        BT  NOT_1ST_RUN4             ;THEN GO TO ACCDEC_PROC
        BRA ACCDEC_PROC
        NOP
NOT_1ST_RUN4:

	MOV #0,R10
	MOV BRK_COUNT1,R0
	MOV.W R10,@R0		;CLEAR COUNTER OF DC BREAK(WHILE START)

        MOV PSTATUS,R1
        MOV.B @R1,R0
        TST #B'100000,R0
        BF TO_STOP_MODE
        ;CHECK EXT FWD,RWD
	MOV OUT_LOOP_1,R14
	JMP @R14;OUT_LOOP
	NOP

TO_STOP_MODE:
;SEQ_FLY1------------------BEGIN-------------------------
        MOV XSTATUS2,R10
        MOV.B @R10,R0
        AND #B'11111110,R0
        MOV.B R0,@R10
;SEQ_FLY1-------------------END--------------------------
;--CLEAR COUNTER OF S CURVE(DECEL COUNTER)IF CHANGE TO STOP MODE (FRUN=FSET=0)--
	MOV #0,R10
	MOV INCREA_D1,R0
	MOV R10,@R0
	MOV MSEC10_D1,R0
	MOV R10,@R0
	MOV INCREA2_D1,R0
	MOV R10,@R0
	MOV MSEC102_D1,R0
	MOV R10,@R0
	MOV INCREA3_D1,R0
	MOV R10,@R0
	MOV MSEC103_D1,R0
	MOV R10,@R0
;--------------------------------------------------------------------	
;FLYING-------------BEGIN--------------------------------------------
;CLEAR FLG & VARIABLE OF SEARCH SPEED WHEN STOP MODE
;FLYINGA
MOV WSTATUS0,R1
MOV.B @R1,R0
TST #B'1000,R0
BT  NOT_CLEAR1
;FLYINGA
        MOV #0,R0
        MOV CLOCK0,R1
        MOV R0,@R1
        MOV S_COUNT0,R1
        MOV.W R0,@R1
;FAST2---------------------BEGIN-------------------------
MOV T_COUNT0,R1
MOV.W R0,@R1
;FAST2----------------------END--------------------------
        MOV S_TIMER0,R1
        MOV.W R0,@R1
;SSL_FLY------------------BEGIN-------------------------
        MOV COUNT_UP0,R1
        MOV.W R0,@R1
        MOV P2000_,R0
        MOV INC_TIME0,R1
        MOV.W R0,@R1
;SSL_FLY-------------------END--------------------------
        MOV W3000_,R0
        MOV WEIGHT0,R1
        MOV.W R0,@R1
        MOV FBACK0,R0
        MOV.W @R0,R0
        MOV FLAST0,R1
        MOV.W R0,@R1

        MOV WSTATUS0,R1
        MOV.B @R1,R0
        AND #B'11110101,R0              ;FLYINGA
        MOV.B R0,@R1
        TST #B'1,R0
        BF  SEARCH_SELECT
        MOV VSTATUS0,R1
        MOV.B @R1,R0
        AND #B'00001111,R0
        MOV.B R0,@R1

SEARCH_SELECT:
        MOV VSTATUS0,R1
        MOV.B @R1,R0
        AND #B'00011111,R0
        MOV.B R0,@R1
NOT_CLEAR1:                             ;FLYINGA
;FLYING--------------END---------------------------------------------

        MOV SYSFLG4,R1
        MOV.B @R1,R0
        AND #B'11011010,R0
        MOV.B R0,@R1

        MOV PSTATUS,R1
        MOV.B @R1,R0
        AND #B'11001111,R0
        MOV.B R0,@R1

;        MOV PA,R1              ;EXT ROM
;        MOV.B @R1,R0
;        AND #B'01111111,R0
;        MOV.B R0,@R1

;        MOV CS1,R1
;        MOV R1,@R1          ;CS1 ACTIVE

        MOV PA,R10
        MOV.B @R10,R0
;        AND #B'01111111,R0              ;INT ROM
        OR #B'10000000,R0
        MOV.B R0,@R10                   ;OFF SST

        MOV PBDRH,R1            ;INT ROM
        MOV.B @R1,R0
        OR #B'10000000,R0
        MOV.B R0,@R1

        MOV D_BUF,R1
        ADD #4,R1
        MOV.B @R1,R0
        AND #B'10111111,R0        ;TURN OFF RUN-LED
        OR  #B'00100000,R0        ;ON STOP-LED
        MOV.B R0,@R1


        MOV DISP_TYPE3,R2
        MOV.B @R2,R0
        CMP/EQ #1,R0
        BF CONTI
        MOV DISP_TB3,R1
        MOV.B @R1,R0
        CMP/EQ #2,R0
        BT RPM_DISPLAY
        CMP/EQ #3,R0
        BT MC_DISPLAY
        MOV #0,R0
        MOV.B R0,@R2
        MOV DATA_B3,R1
        ADD #4,R1
        MOV.B @R1,R0
        OR  #B'00000100,R0
        AND #B'11100111,R0
        MOV.B R0,@R1
        BRA CONTI
        NOP
RPM_DISPLAY:
        MOV.B R0,@R2
        BRA CONTI1
        NOP
MC_DISPLAY:
        MOV.B R0,@R2
CONTI1:
        MOV DATA_B3,R1
        ADD #4,R1
        MOV.B @R1,R0
        OR  #B'00010000,R0
        AND #B'11110011,R0
        MOV.B R0,@R1
CONTI:

;2/6/42
;        MOV FLAST2,R0
;        MOV.W @R0,R0
;        MOV FSET11,R1
;        MOV.W R0,@R1

;        MOV R0,R10
;        MOV TSTATUS2,R1
;        MOV.B @R1,R0
;        TST #B'10,R0
;        BT  OUT_NA_JA
;        AND #B'11111101,R0
;        MOV.B R0,@R1
;        MOV #104,R11
;        MOV EEWRITE1,R14
;        JSR @R14;EE_WR
;        NOP
;2/6/42
OUT_NA_JA:
        MOV DIG_TOG1,R0
        MOV.B @R0,R1
        MOV #4,R1
        MOV.B R1,@R0
        MOV OUT_LOOP_1,R14
	JMP @R14;OUT_LOOP
	NOP

	.ALIGN 4
PSTATUS: .DATA.L _P_STATUS
FSET11:  .DATA.L FSET
FLAST2:  .DATA.L FLAST
RSTATUSB:.DATA.L _R_STATUS
FRUN2:   .DATA.L FRUN
SYSFLG4: .DATA.L SYSFLG
D_BUF:   .DATA.L _DATA_BUF
PA:      .DATA.L H'5FFFFC0
PBDRH:   .DATA.L H'5FFFFC2
CS1:     .DATA.L H'1000000
INCREA_D1:  .DATA.L D_INCREA_
INCREA2_D1: .DATA.L D_INCREA2_
INCREA3_D1: .DATA.L D_INCREA3_
MSEC10_D1:  .DATA.L D_MSEC10_
MSEC102_D1: .DATA.L D_MSEC102_
MSEC103_D1: .DATA.L D_MSEC103_
BRK_COUNT1: .DATA.L _BRK_COUNT
OUT_LOOP_1: .DATA.L OUT_LOOP
EEWRITE1:    .DATA.L EE_WR
TSTATUS2:   .DATA.L _T_STATUS
DISP_TB3:   .DATA.L _DISP_TB
DISP_TYPE3: .DATA.L _DISP_TYPE
DATA_B3:    .DATA.L _DATA_BUF
DIG_TOG1:   .DATA.L _DIG_TOG
CLOCK0:     .DATA.L _CLOCK
S_COUNT0:   .DATA.L _S_COUNT
S_TIMER0:   .DATA.L _S_TIMER
W3000_:     .DATA.L 3000
WEIGHT0:    .DATA.L _WEIGHT
FBACK0:     .DATA.L _FBACK
FLAST0:     .DATA.L FLAST
WSTATUS0:   .DATA.L _W_STATUS
VSTATUS0:   .DATA.L _V_STATUS
T_COUNT0:   .DATA.L _T_COUNT
P2000_:     .DATA.L 2000
COUNT_UP0:  .DATA.L _COUNT_UP
INC_TIME0:  .DATA.L _INC_TIME
XSTATUS2:   .DATA.L _X_STATUS
        .ALIGN 4
;------------------------------------------------------------------------------
ACCDEC_PROC:
;---------------IF NOT RUN MODE THEN OUT OF ACCDEC_PROC------------------------

	MOV SYSFLGB,R0
	MOV.B @R0,R0
	TST #B'100,R0		;IF RUN MODE 
	BF  ACCDEC_PROC1	;THEN JMP TO ACCDEC_PROC1

	MOV PSTATUSB,R0
	MOV.B @R0,R0
	TST #B'10000,R0		;IF NOT FIRST RUN
	BT  OUTLOOP_AA		;THEN OUTLOOP
	BRA ACCDEC_PROC1
	NOP
OUTLOOP_AA:
	BRA OUTLOOP_A
	NOP
;------------------------------------------------------------------------------
ACCDEC_PROC1:
;-----------------CHECK STALL PREVENTION---------------------------------------	
	MOV STALL,R0
	MOV.B @R0,R0
	CMP/EQ #0,R0		;IF USER SELECT 0 (STALL PREVENTION INACTIVE)
        BF  NOT_DYN_BRK         ;THEN JMP TO CHECK DYNAMIC BREAK CONTINUE
        BRA DYN_BRK
        NOP
NOT_DYN_BRK:
        MOV #2,R1
	CMP/EQ R1,R0		;IF USER SELECT 2 (STALL ONLY VOLT)
        BF  STALL_CURRENT
        BRA STALL_VOLT          ;THEN JMP TO STALL_VOLT
        NOP
STALL_CURRENT:

	MOV PSTATUSB,R0
	MOV.B @R0,R0
	TST #B'100000,R0	;IF DECEL TO STOP
	BT  I_STALL		
	MOV QSTATUS,R1		;THEN CLEAR STALL CURRENT FLAG
	MOV.B @R1,R0		;AND NOT CHECK STALL CURRENT
	AND #B'11111101,R0
	MOV.B R0,@R1
	BRA CHKIV
	NOP
I_STALL:
	MOV SYSFLGB,R1
	MOV.B @R1,R0
	TST #B'100000,R0	;IF ACC FLAG SET
	BT  ACC_STILL		;THEN CHECK STALL CURRENT CONTINUE
	MOV QSTATUS,R1		;ELSE CLEAR STALL CURRENT FLAG
	MOV.B @R1,R0		;AND NOT CHECK STALL CURRENT
	AND #B'11111101,R0
	MOV.B R0,@R1
	BRA CHKIV
	NOP
ACC_STILL:
	
;        MOV IDREAL,R0
;        MOV @R0,R1
;        MOV IQREAL,R0
;        MOV @R0,R2
;        MULS R1,R1
;        STS MACL,R3
;        MULS R2,R2
;        STS MACL,R4
;        ADD R3,R4               ;R4=ID^2+IQ^2
;        MOV IMAX,R1

        MOV IMOTOR1,R1
	MOV @R1,R1
;FAST3----------BEGIN--------------------------------
        MOV PERCENT_STALL,R0
        MOV.W @R0,R0
        MULS R0,R1
        STS MACL,R1
        MOV #100,R0
        DIVS R0,R1
;FAST3-----------END---------------------------------
        MOV #15,R0
	MULS R0,R1
        STS MACL,R2             ;IMPROVE2(R1-->R2)
        MOV #10,R0
        DIVSN R0,R2             ;R1=1.5*IMOTOR;IMPROVE2(DIVS-->DIVSN R2)
        MOV R2,R1               ;IMPROVE2
        MOV IRMS1,R4
        MOV @R4,R4              ;R4=RMS OF REAL CURRENT

        CMP/GT R1,R4            ;IF R4 </= IMAX
	BF  CHECKIMIN		;THEN JMP TO CHECK IMIN
	MOV QSTATUS,R3		;ELSE SET STALL CURRENT FLAG
	MOV.B @R3,R0
	OR  #B'10,R0
	MOV.B R0,@R3
CHECKIMIN:
	MOV QSTATUS,R3
	MOV.B @R3,R0
	TST #B'10,R0		;IF NOT STALL CURRENT 
	BT  CHKIV		;THEN JMP TO CHECK I&V STALL? 
;        MOV IMIN,R1             ;ELSE IF STALL CURRENT FLAG SET CHECK

        MOV IMOTOR1,R1
	MOV @R1,R1
;FAST3----------BEGIN--------------------------------
        MOV PERCENT_STALL,R0
        MOV.W @R0,R0
        MULS R0,R1
        STS MACL,R1
        MOV #100,R0
        DIVS R0,R1
;FAST3-----------END---------------------------------

        MOV #13,R0
	MULS R0,R1
        STS MACL,R2             ;IMPROVE2(R1-->R2)
        MOV #10,R0
        DIVSN R0,R2             ;R1=1.3*IMOTOR;IMPROVE2(DIVS-->DIVSN R2)
        MOV R2,R1               ;IMPROVE2

        CMP/GE R4,R1            ;THEN CHECK THAT IF R4 >/= IMIN
	BF  CHKIV		;THEN JMP TO CHECK I&V STALL?
	MOV.B @R3,R0		;ELSE IF R4<IMIN THEN CLEAR STALL CURRENT FLAG
	AND #B'11111101,R0
	MOV.B R0,@R3 
	
CHKIV:
	MOV STALL,R0
	MOV.B @R0,R0
	MOV #3,R1
	CMP/EQ R1,R0		;IF USER DON'T  SELECT 3 (I&V STALL) 
	BF  DYN_BRK		;THEN JMP TO DYNAMIC BREAK 

STALL_VOLT:

;	MOV READ_DCBUS,R14
;	JSR @R14;READ_VDC
;	NOP

	MOV SYSFLGB,R1
	MOV.B @R1,R0
	TST #B'100000,R0	;IF DEC FLAG SET 
	BF  DEC_STILL		;THEN CHECK STALL VOLT
	MOV QSTATUS,R1		;ELSE CLEAR STALL VOLT FLAG
	MOV.B @R1,R0		;AND NOT CHECK STALL VOLT
	AND #B'11111110,R0
	MOV.B R0,@R1
	BRA DYN_BRK
	NOP
DEC_STILL:

        MOV SERIES1,R1          ;CHECK INVERTER FOR 220V OR 380V.
        MOV.B @R1,R1
        MOV #80,R2
        CMP/GT R2,R1
        BT  INV220_1
        MOV MAXDC,R1            ;R1=VDC MAX
        BRA INV380_1
        NOP
INV220_1:
        MOV MAXDC220,R1
INV380_1:
        MOV DCBUS,R2
	MOV @R2,R2		;R2=REAL VDC
	CMP/GT R1,R2		;IF REAL VDC </=MAX VDC(REF.)
	BF  CHECK670		;THEN CHECK MINIMUM DC CONTINUE
	MOV QSTATUS,R3		;ELSE SET STALL VOLT FLAG
	MOV.B @R3,R0
	OR  #B'1,R0
	MOV.B R0,@R3
CHECK670:
	MOV QSTATUS,R3		
	MOV.B @R3,R0
	TST #B'1,R0		;IF STALL VOLT FLAG NOT SET
	BT  DYN_BRK		;THEN JMP DYNAMIC BREAK

        MOV SERIES1,R1
        MOV.B @R1,R1
        MOV #80,R2
        CMP/GT R2,R1
        BT  INV220_3
        MOV MINDC,R1            ;ELSE CHECK VDC MIN CONTINUE
        BRA INV380_3
        NOP
INV220_3:
        MOV MINDC220,R1
INV380_3:
        MOV DCBUS,R2
        MOV @R2,R2              ;R2=REAL VDC
        CMP/GE R2,R1            ;IF REAL VDC >/= MIN VDC(REF.)
	BF  DYN_BRK		;THEN JMP TO DYNAMIC BREAK
	MOV QSTATUS,R3		;ELSE CLEAR STALL VOLT FLAG
	MOV.B @R3,R0
	AND #B'11111110,R0
	MOV.B R0,@R3
DYN_BRK: 
;	MOV READ_DCBUS,R14
;	JSR @R14;READ_VDC
;	NOP

        MOV SERIES1,R1
        MOV.B @R1,R1
        MOV #80,R2
        CMP/GT R2,R1
        BT  INV220_2
        MOV MAXDC,R1
        BRA INV380_2
        NOP
INV220_2:
        MOV MAXDC220,R1
INV380_2:
        MOV DCBUS,R2
	MOV @R2,R2
        CMP/GT R1,R2            ;IF MAX VDC(REF.) > REAL VDC
	BF  CHECKLOW		;THEN CHECK MIN VDC CONTINUE
;        MOV PA_LOW,R1           ;ELSE ENABLE DYNAMIC BREAK (PA2=0)
;        MOV.B @R1,R0           ;EXT ROM
;        AND #B'11111011,R0
;        MOV.B R0,@R1
        MOV PB_LOW,R1           ;ELSE ENABLE DYNAMIC BREAK (PB0=0)
        MOV.B @R1,R0            ;INT ROM
        AND #B'11111110,R0
        MOV.B R0,@R1

CHECKLOW:
;        MOV PA_LOW,R1          ;EXT ROM
;        MOV.B @R1,R0
;        TST #B'100,R0           ;IF PA2 = 1(DYNAMIC BREAK NOT ACTIVE)

        MOV PB_LOW,R1           ;INT ROM
        MOV.B @R1,R0
        TST #B'1,R0             ;IF PB0 = 1(DYNAMIC BREAK NOT ACTIVE)
        BF  OUT_CHK_STALL       ;THEN OUT OF STALL CHECKING

        MOV SERIES1,R1
        MOV.B @R1,R1
        MOV #80,R2
        CMP/GT R2,R1
        BT  INV220_4
        MOV MINDC,R1            ;ELSE CHECK MINIMUM VDC CONTINUE
        BRA INV380_4
        NOP
INV220_4:
        MOV MINDC220,R1
INV380_4:
        MOV DCBUS,R2
        MOV @R2,R2              ;R2=REAL VDC

        CMP/GE R2,R1            ;IF MINIMUM VDC(REF.)< REAL VDC
	BF  OUT_CHK_STALL	;THEN OUT OF STALL CHECKING
;        MOV PA_LOW,R1           ;ELSE DISABLE DYNAMIV BREAK(PA2=1)
;        MOV.B @R1,R0           ;EXT ROM
;        OR  #B'100,R0
;        MOV.B R0,@R1

        MOV PB_LOW,R1           ;ELSE DISABLE DYNAMIV BREAK(PB0=1)
        MOV.B @R1,R0            ;INT ROM
        OR  #B'1,R0
        MOV.B R0,@R1

OUT_CHK_STALL:
	MOV QSTATUS,R0
	MOV.B @R0,R0
	TST #B'1,R0		;IF STALL VOLT FLAG NOT SET 
	BT  CHK_STALL_I		;THEN CHECK STALL CURRENT FLAG CONTINUE
	MOV OUT_OF_LOOP,R14	;ELSE OUT OF LOOP(NOT GO TO ACC/DEC PROCESS)
	JMP @R14;OUT_LOOP
	NOP
CHK_STALL_I:
	MOV QSTATUS,R0
	MOV.B @R0,R0
	TST #B'10,R0		;IF STALL CURRENT FLAG NOT SET 
	BT  ACCDEC_PROC2	;THEN GO TO ACC/DEC PROCESS 

OUTLOOP_A:

	MOV OUT_OF_LOOP,R14	;ELSE OUT OF LOOP(NOT GO TO ACC/DEC PROCESS)
	JMP @R14;OUT_LOOP
	NOP

	.ALIGN 4
STALL:		.DATA.L _STALL
;READ_DCBUS:	.DATA.L READ_VDC
MAXDC:          .DATA.L 3186;3379            ;690 V.*8/SQRT(3)
MINDC:          .DATA.L 3094;3281            ;670 V.*8/SQRT(3)
MAXDC220:       .DATA.L 3040;((2640/2489)*3040));3224      ;380 V.*8
MINDC220:       .DATA.L 2880;((2640/2489)*2880));3055      ;360 V.*8
SERIES1:        .DATA.L _SERIES
DCBUS:          .DATA.L _V_DC
IMIN:		.DATA.L 1769472		;IDMIN^2+IQMIN^2=12^2A.(IRMS=SQRT(ID^2+IQ^2)/3 BECAUSE WE USE DELTA EQUIVALENT CIRCUIT)
IMAX:		.DATA.L 2242803		;IDMAX^2+IQMAX^2=13.5^2A.(1.5 OF RATED CURRENT (5.2 ARMS))
IDREAL:		.DATA.L _ID_REAL	
IQREAL:		.DATA.L _IQ_REAL
QSTATUS:	.DATA.L _Q_STATUS
SYSFLGB:	.DATA.L SYSFLG
PSTATUSB:	.DATA.L _P_STATUS
PA_LOW:		.DATA.L H'5FFFFC1
PB_LOW:         .DATA.L H'5FFFFC3
IMOTOR1:        .DATA.L I_MOTOR
IRMS1:		.DATA.L I_RMS
PERCENT_STALL:  .DATA.L _PERCENT_STALL
OUT_OF_LOOP:    .DATA.L OUT_LOOP
	.ALIGN 4

ACCDEC_PROC2:	
;-------WHEN STR/STP BY KEY BUT NO FWD,RWD SIGNAL THEN DC BREAK NOT RUN--------

        MOV R_STUS,R0
	MOV.B @R0,R0
	TST #B'1000,R0		;IF THERE ARE FWD OR RWD SIGNAL 
	BT  CHECK_BREAK		;THEN JMP TO CHECK_BREAK 

	MOV FRUN_START1,R0
	MOV.W @R0,R0
	CMP/EQ #0,R0		;IF FRUN_START <> 0
	BF OUTLOOP_B		;THEN OUTLOOP_B

	BRA CHECK_STP_BRK
	NOP

OUTLOOP_B:
	MOV #0,R1
	MOV FRUNB,R0
	MOV.W R1,@R0		;WHEN DC BREAK(START) RUN FRUN=0
	
;OUTLOOP_A:
	BRA OUTLOOP
	NOP

;-----------CHECK DC BREAK---------------------------------------------------

CHECK_BREAK:
	MOV #0,R0
	MOV FRUN_START1,R1		;RESET FRUN_START
	MOV.W R0,@R1
	MOV BRK_TIME,R0
	MOV.W @R0,R1			;GET BREAK TIME
;	MOV SIMTIME,R1
	MOV BRK_COUNT,R0
	MOV.W @R0,R2
        CMP/GE R1,R2                    ;IF BREAK COUNTER > BREAK TIME
	BT  CHECK_STP_BRK		;THEN CHECK DC BREAK(STOP) CONTINUE 
	ADD #1,R2			;INCREASE COUNTER
	MOV.W R2,@R0			;STORE COUNTER
        MOV R_STUS,R1
	MOV.B @R1,R0
	OR #B'00110000,R0
	MOV.B R0,@R1			;SET DC BREAK(START) FLAG
;SSL_BREAK------------BEGIN--------------------------------------
;SOFT1---------------BEGIN---------------------------------------
;        MOV SYSFLG_5,R1
;        ADD #1,R1
;        MOV.B @R1,R0
;        TST #B'100,R0
;        BF  INIT_10
;        TST #B'10,R0
;        BT  NOT_INIT
;INIT_10:
;        MOV FLUX_COUNT3,R1              ;INITIAL FLUX_COUNT 10% FOR SSL
;        MOV #10,R0
;        MOV.B R0,@R1
;NOT_INIT:
;SOFT1----------------END-----------------------------------------
;SSL_BREAK------------END-----------------------------------------
	MOV FRUNB,R0
	MOV #0,R1			;WHEN DC BREAK RUN FRUN MUST BE ZERO
	MOV.W R1,@R0

	MOV QSTATUS3,R0
	MOV.B @R0,R0
	TST #B'10000,R0			;IF USER NOT SELECT ZERO START FUNCTION
	BT  NON_ZERO			;THEN OUT_LOOP
	MOV FLASTB,R0			;ELSE STORE ZERO TO FLAST
	MOV.W R1,@R0
NON_ZERO:	
	BRA OUTLOOP
	NOP

CHECK_STP_BRK:

        MOV FSETB,R0
        MOV.W @R0,R0
        MOV STPFRE,R1
        MOV.W @R1,R1
        CMP/GE R1,R0                    ;IF FSET < STOPFREQ.
        BT S_OR_LINEAR                  ;THEN NOT BREAK(STOP)

	MOV FRUNB,R0
	MOV.W @R0,R1
;	MOV #50,R2   			;STP FREQUENCY
	MOV STPFRE,R2
	MOV.W @R2,R2
	CMP/GE R1,R2			;IF STOP FREQ < FRUN 
	BF  S_OR_LINEAR			;THEN NOT BREAK

        MOV FRUNB,R0
        MOV #0,R1                       ;WHEN FRUN < STOP FREQ. FRUN MUST BE ZERO
        MOV.W R1,@R0

        MOV STOPTIMES,R0
	MOV.W @R0,R1			;GET BREAK TIME(STOP)
;	MOV SIMTIME,R1
	MOV BRK_COUNT_S,R0
	MOV.W @R0,R2
        CMP/GE R1,R2                    ;IF BREAK COUNTER > BREAK TIME(STOP)
	BT  S_OR_LINEAR			;THEN OUT OF DC BREAK(STOP)
	ADD #1,R2			;INCREASE COUNTER OF DC BREAK(STOP)
	MOV.W R2,@R0			;STORE COUNTER
        MOV R_STUS,R1
	MOV.B @R1,R0
	OR #B'00100000,R0		;SET DC BREAK FLAG
	AND #B'11101111,R0		;SET DC BREAK(STOP) FLAG
	MOV.B R0,@R1
	MOV FRUNB,R0
	MOV #0,R1			;WHEN DC BREAK RUN FRUN MUST BE ZERO
	MOV.W R1,@R0
;        MOV PBDRH1,R10
;        MOV.B @R10,R0
;        AND #B'01111111,R0              ;EXT ROM
;        MOV.B R0,@R10                   ;OFF SST

        MOV PA_,R10
        MOV.B @R10,R0
;        AND #B'01111111,R0              ;INT ROM
        OR #B'10000000,R0
        MOV.B R0,@R10                   ;OFF SST

        BRA OUTLOOP
	NOP

S_OR_LINEAR:
        MOV STOPTIMES,R0
        MOV.W @R0,R1                    ;GET BREAK TIME(STOP)
        MOV BRK_COUNT_S,R0
        MOV.W @R0,R2
        CMP/GE R1,R2                    ;IF BREAK COUNTER > BREAK TIME(STOP)
        BF  FWD_REW                 ;THEN OUT OF DC BREAK(STOP)

        MOV R_STUS,R0
        MOV.B @R0,R0
        TST #B'1000,R0          ;IF THERE ARE FWD OR RWD SIGNAL
        BT  FWD_REW             ;THEN JMP TO FWD_REW

        MOV FRUN_START1,R0
        MOV.W @R0,R0
        CMP/EQ #0,R0            ;IF FRUN_START <> 0
        BF  FWD_REW             ;THEN FWD_REW
        MOV FRUNB,R1
;        MOV.W R0,@R1
        MOV.W @R1,R3
        MOV STPFRE,R2
        MOV.W @R2,R2
        CMP/GE R2,R3
        BT FWD_REW
        MOV.W R0,@R1

        MOV R_STUS,R1
        MOV.B @R1,R0
        AND #B'11011111,R0      ;CLEAR DC BREAK FLAG
        MOV.B R0,@R1
;        MOV PA_,R1                ;ELSE OFF OPTO
;        MOV.B @R1,R0           ;EXT ROM
;        AND #B'01111111,R0
;        MOV.B R0,@R1
;        MOV CS1_,R2
;        MOV R2,@R2          ;CS1 ACTIVE

        MOV PBDRH1,R1           ;ELSE OFF OPTO
        MOV.B @R1,R0            ;INT ROM
        OR #B'10000000,R0
        MOV.B R0,@R1

        BRA OUTLOOP
        NOP
FWD_REW:

        MOV FSETB,R1
        MOV.W @R1,R1
        MOV STRFRE1,R0
        MOV.W @R0,R0
        CMP/GE R0,R1            ;IF FSET < STRFREQ.
        BF  NOT_CLEAR_COUNT     ;THEN NOT CLEAR BRK_COUNT OF STOP BREAK(BUT MUST CLEAR DC BREAK FLAG)

        MOV BRK_COUNT_S,R0      ;ELSE CLEAR BRK_COUNT_S
        MOV #0,R1
        MOV.W R1,@R0            ;RESET COUNTER OF DC BRAKE
NOT_CLEAR_COUNT:
        MOV R_STUS,R1
        MOV.B @R1,R0
        AND #B'11011111,R0      ;CLEAR DC BREAK FLAG
        MOV.B R0,@R1    

	MOV PSTATUS4,R0
	MOV.B @R0,R0
	TST #B'100000,R0	;IF DECEL TO STOP 
	BF ACTIVE		;THEN NOT CHECK FSET BELOW START FREQ.
	MOV STRFRE1,R0
	MOV.W @R0,R0
	MOV FSETB,R1
	MOV.W @R1,R1
        CMP/GT R1,R0            ;IF START FREQ. > FSET
        BF ACTIVE
;BRA $
;NOP
        MOV #0,R1               ;THEN FRUN=0
	MOV FRUNB,R3
	MOV.W @R3,R2
	CMP/GT R0,R2		;IF FRUN > START FREQ.(FOR CHECK CASE OF CHANGING FROM MUL.SPEED TO FSET(<STR. FREQ.)
	BT ACTIVE		;THEN NORMAL CHECK(IN THIS CASE SHOULD DECEL FROM MUL.SPEED TO STR.FREQ.)
	MOV.W R1,@R3		;ELSE STORE 0 TO FRUN
	BRA OUT_LOOP
	NOP
ACTIVE:

	MOV QSTATUS3,R0
	MOV.B @R0,R0
	TST #B'100,R0		;IF JOG IN 
	BF  JOG_IN		;THEN USE LINEAR ACC/DEL

	TST #B'1000,R0		;IF SOFT IN 
	BF JOG_IN		;THEN USE LINEAR ACC/DEL

        MOV R_STUS,R0
	MOV.B @R0,R0
	TST #B'1000000,R0	;IF USER SELECT S_CURVE
	BF  S_SHAPE		;THEN JMP TO S_SHAPE 
JOG_IN:
	MOV PSTATUS4,R1
	MOV.B @R1,R0
	TST #B'100000,R0	;IF UP/DOWN CON. AND NO X1,X2 BUT DCT 
	BF  NOT_UP_DW		;THEN NOT_UP_DOWN
	MOV S_STATUS5,R1
	MOV.B @R1,R0
	TST #B'100000,R0	;IF UP/DOWN CON. BUT NO X1,X2
	BT NOT_UP_DW		
	BRA OUTLOOP		;THEN OUTLOOP(NOT ACC,DEC PROCESS)
	NOP
        .ALIGN 4
R_STUS:      .DATA.L _R_STATUS
FRUN_START1: .DATA.L _FRUN_START
BRK_TIME:    .DATA.L _BRK_TIME
BRK_COUNT:   .DATA.L _BRK_COUNT
FRUNB:       .DATA.L FRUN
FSETB:       .DATA.L FSET
FLASTB:      .DATA.L FLAST
STPFRE:      .DATA.L _STP_FRE      ;STOP FREQUENCY
QSTATUS3:    .DATA.L _Q_STATUS
STOPTIMES:   .DATA.L _STOPTIME
BRK_COUNT_S: .DATA.L _BRK_COUNT_S
PA_:         .DATA.L H'5FFFFC0
CS1_:        .DATA.L H'1000000
PBDRH1:      .DATA.L H'5FFFFC2
SYSFLG_5:    .DATA.L SYSFLG
FLUX_COUNT3: .DATA.L _FLUX_COUNT
        .ALIGN 4
NOT_UP_DW:
	.INCLUDE "ACCDEC.H"	;ELSE GO TO LINEAR ACC/DEL
OUTLOOP:
	BRA OUT_LOOP
	NOP
	.ALIGN 4
R_STATUS: .DATA.L _R_STATUS
PSTATUS4: .DATA.L _P_STATUS
S_STATUS5:.DATA.L _S_STATUS
SIMTIME:  .DATA.L 5000
;STOPTIMES: .DATA.L _STOPTIME
;BRK_COUNT_S:.DATA.L _BRK_COUNT_S
;FSETB:   .DATA.L FSET
;FLASTB:   .DATA.L FLAST
;STPFRE:   .DATA.L _STP_FRE      ;STOP FREQUENCY
STRFRE1:  .DATA.L _STR_FRE
P_DLY:  .DATA.L PULSE_DLY
;PBDRH1:   .DATA.L H'5FFFFC2
	.ALIGN 4
S_SHAPE1:

	MOV PSTATUS5,R1
	MOV.B @R1,R0
	TST #B'100000,R0		;IF UP/DWN AND NO X1,X2 BUT DCT.
	BF  NOT_UP_DW1			;THEN NOT_UP_DW1
	MOV S_STATUS6,R1
	MOV.B @R1,R0
	TST #B'100000,R0		;IF UP/DWN BUT NO X1,X2
	BT NOT_UP_DW1			;THEN OUTLOOP(NOT ACC,DEC PROCESS)
	BRA OUTLOOP
	NOP
NOT_UP_DW1:

	MOV FRUNS3_,R0
	MOV.W @R0,R1
	MOV FSETS3_,R0
	MOV.W @R0,R2
	CMP/EQ R1,R2		;IF FSET=FRUN 
        BF  NOT_EQUAL            ;THEN OUT_LOOP(NOT CALCULATE S_CURVE)
        BRA OUT_LOOP2
        NOP
NOT_EQUAL:
        CMP/GT R2,R1            ;IF FRUN > FSET
        BF  NOT_DEC_S         ;THEN DECEL OF S_SHAPE
        BRA DEC_S_SHAPE1
        NOP
NOT_DEC_S:
        MOV SYSFLG5,R1
	MOV.B @R1,R0
	AND #B'11011111,R0
	MOV.B R0,@R1
;------ACCEL OF S_SHAPE--------------------------------------------------
;--CLEAR COUNTER OF S CURVE(DECEL COUNTER)IF USER PRESS RUN KEY-------------
	MOV #0,R10
	MOV INCREA_D,R0
	MOV R10,@R0
	MOV MSEC10_D,R0
	MOV R10,@R0
	MOV INCREA2_D,R0
	MOV R10,@R0
	MOV MSEC102_D,R0
	MOV R10,@R0
	MOV INCREA3_D,R0
	MOV R10,@R0
	MOV MSEC103_D,R0
	MOV R10,@R0
	MOV D_REMAINDER1,R0
	MOV R10,@R0
;--------------------------------------------------------------------	
;--------------------------------------------------------------------
;CHECK THAT WHEN FRUN NOT ACCEL TO FSET IF FSET HAVE CHANGE
;(FSET CHANGE WHILE ACCEL) THEN MUST CLEAR COUNTER OF ACCEL S CURVE
;--------------------------------------------------------------------
        MOV FSETS,R0
        MOV.W @R0,R2
        MOV INITIALA,R0
        MOV @R0,R1
        SUB R1,R2
        MOV #20,R0
        MULS R0,R2
        STS MACL,R2                     ;R2=(FSET-INITIALA)*20=DELTAF
        MOV DELTAF,R0
        MOV @R0,R1
        CMP/EQ R1,R2                    ;IF R2=DELTAF
        BT  START_ACCEL_S               ;THEN START_ACCEL_S
        MOV #0,R10                      ;ELSE CLEAR COUNTER (FSET HAVE CHANGE
        MOV INCREA_A,R0                 ;BEFORE FRUN --> FSET
        MOV R10,@R0
        MOV MSEC10_A,R0
        MOV R10,@R0
        MOV INCREA2_A,R0
        MOV R10,@R0
        MOV MSEC102_A,R0
        MOV R10,@R0
        MOV INCREA3_A,R0
        MOV R10,@R0
        MOV MSEC103_A,R0
        MOV R10,@R0
        MOV REMAINDER2,R0
        MOV R10,@R0

START_ACCEL_S:
;--CALCULATE PARAMETER(AMAX,KRATE1,KRATE2,INITIAL1,INITIAL2) FOR S_CURVE(ACC)--------
	MOV MSEC10,R0
	MOV @R0,R0
	CMP/EQ #0,R0		;IF NOT FIRST TIME TO S_CURVE
	BF  NOT_FIRST   	;THEN SKIP TO CALCULATE PARAMETER
	MOV FRUNS,R0		;ELSE STORE FRUN FOR INITIAL VALUE
	MOV.W @R0,R1
	MOV INITIALA,R0
	MOV R1,@R0
	MOV FSETS,R0
	MOV.W @R0,R2
	SUB R1,R2
	SHLL R2
	MOV R2,R1

	SHAR R2
	MOV #10,R0
	MULS R0,R2
	STS MACL,R2
	SHLL R2
	MOV DELTAF,R0		;CALCULATE 2*|FSET-FRUN(INITIAL)|
	MOV R2,@R0

	MOV SQROOT,R14		;FIND SCALE FACTOR {SQRT(|FSET-FRUN|/50Hz)}
	JSR @R14;SQ_ROOT	;R13 = SCALE FACTOR	
	NOP

	MOV ACC_START,R0
	MOV @R0,R1
	MULS R1,R13
	STS MACL,R1
	MOV #100,R12
	DIVS R12,R1
	MOV ACC_START_R,R0	;ACC_START_R = SCALE FACTOR*ACC_START
	MOV R1,@R0	
	
	MOV ACC_LIN,R0
	MOV @R0,R2
	MULS R2,R13
	STS MACL,R2
	MOV #100,R12
	DIVS R12,R2
	MOV ACC_LIN_R,R0	;ACC_LIN_R = SCALE FACTOR*ACC_LIN
	MOV R2,@R0

	MOV ACC_END,R0
	MOV @R0,R3
	MULS R3,R13
	STS MACL,R3
	MOV #100,R12
	DIVS R12,R3
	MOV ACC_END_R,R0	;ACC_END_R = SCALE FACTOR*ACC_END
	MOV R3,@R0
	
NOT_FIRST:
	BRA CONTINUE
	NOP
;------------------------------------------------------------------
OUT_LOOP2:
	BRA OUT_LOOP1
	NOP
DEC_S_SHAPE1:
	BRA DEC_S_SHAPE
	NOP
;-------------------------------------------------------------------
CONTINUE:
	MOV ACC_START_R,R0	;R1 = ACC_START_R (TIME FOR ACCEL START-
	MOV @R0,R1		;WHEN MULTIPLIED BY SCALE FACTOR)

	MOV ACC_LIN_R,R0	;R2 = ACC_LIN_R (TIME FOR ACCCEL LINEAR-
	MOV @R0,R2		;WHEN MULTIPLIED BY SCALE FACTOR)

	MOV ACC_END_R,R0	;R3 = ACC_END_R (TIME FOR ACCEL END-
	MOV @R0,R3		;WHEN MULTIPLIED BY SCALE FACTOR)
	

	MOV R2,R4
	MOV R1,R6
	SHLL R4
	ADD R1,R4
	ADD R3,R4

	MOV DELTAF,R5
	MOV @R5,R5

	DIVS R4,R5
	MOV AMAX,R0		;AMAX=2*|FSET-FRUN(INITIAL)|/(T1+2*T2+T3)	
	MOV R5,@R0
	MOV R5,R7
	MOV R5,R8
	DIVS R1,R5
	MOV KRATE1,R0		;KRATE1=AMAX/T1
	MOV R5,@R0
	MULS R5,R6
	STS MACL,R5
	MULS R5,R6
	STS MACL,R5
	SHAR R5
	MOV #10,R10
	DIVS R10,R5
	MOV INITIALA,R13
	MOV @R13,R13
	ADD R13,R5
	MOV INITIAL1,R0		;INITIAL1=0.5*KRATE1*T1^2/10
	MOV R5,@R0
	DIVS R3,R7
	MOV KRATE2,R0		;KRATE2=AMAX/T3
	MOV R7,@R0
	MULS R2,R8		
	STS MACL,R8
	MOV #10,R10
	DIVS R10,R8
	ADD R5,R8
	MOV INITIAL2,R0		;INITIAL2=INITIAL1+(AMAX*T2)/10
	MOV R8,@R0	
;---------------------------------------------------------------

	MOV ACC_START_R,R0	;GET ACC_START_R TIME FOR COMPARE
	MOV @R0,R1

	MOV #10,R0		;SCALE TIME WITH 10
	MULS R0,R1
	STS MACL,R1

	MOV _MSEC10,R0
	MOV @R0,R0
	CMP/EQ R1,R0		;IF TIME = ACC_START TIME
	BT LINEAR  		;THEN CHANGE TO LINEAR RANGE
	.INCLUDE "S_CURVE1.H"	;ELSE GO TO SOFT ACCCEL START
	BRA OUT_LOOP
	NOP


LINEAR: BRA LINEAR1
	NOP

	.ALIGN 4
SQROOT:  .DATA.L SQ_ROOT
N1000:   .DATA.L 1000
DELTAF:  .DATA.L _DELTAF
AMAX:    .DATA.L _AMAX
ACC_START: .DATA.L _ACC_START
ACC_LIN:   .DATA.L _ACC_LIN
ACC_END:   .DATA.L _ACC_END
KRATE1:    .DATA.L _KRATE1
KRATE2:    .DATA.L _KRATE2
INITIALA:  .DATA.L _INITIALA
INITIAL1:  .DATA.L _INITIAL1
INITIAL2:  .DATA.L _INITIAL2
ACC_START_R: .DATA.L _ACC_START_R
ACC_LIN_R:   .DATA.L _ACC_LIN_R
ACC_END_R:   .DATA.L _ACC_END_R
SYSFLG5:   .DATA.L SYSFLG
PSTATUS5:   .DATA.L _P_STATUS
S_STATUS6:  .DATA.L _S_STATUS
	.ALIGN 4

OUT_LOOP1:
;-----CLEAR COUNTER OF S CURVE(ACCEL COUNTER) IF FSET=FRUN -----------------------------
	MOV #0,R10
	MOV INCREA_A,R0
	MOV R10,@R0
	MOV MSEC10_A,R0
	MOV R10,@R0
	MOV INCREA2_A,R0
	MOV R10,@R0
	MOV MSEC102_A,R0
	MOV R10,@R0
	MOV INCREA3_A,R0
	MOV R10,@R0
	MOV MSEC103_A,R0
	MOV R10,@R0
	MOV INCREA_D,R0
	MOV R10,@R0
	MOV MSEC10_D,R0
	MOV R10,@R0
	MOV INCREA2_D,R0
	MOV R10,@R0
	MOV MSEC102_D,R0
	MOV R10,@R0
	MOV INCREA3_D,R0
	MOV R10,@R0
	MOV MSEC103_D,R0
	MOV R10,@R0
	BRA OUT_LOOP
	NOP
;-----------------------------------------------------------------

	.ALIGN 4
INCREA_A:  .DATA.L INCREA_
INCREA2_A: .DATA.L INCREA2_
INCREA3_A: .DATA.L INCREA3_
MSEC10_A:  .DATA.L MSEC10_
MSEC102_A: .DATA.L MSEC102_
MSEC103_A: .DATA.L MSEC103_
INCREA_D:  .DATA.L D_INCREA_
INCREA2_D: .DATA.L D_INCREA2_
INCREA3_D: .DATA.L D_INCREA3_
MSEC10_D:  .DATA.L D_MSEC10_
MSEC102_D: .DATA.L D_MSEC102_
MSEC103_D: .DATA.L D_MSEC103_
D_REMAINDER1: .DATA.L _D_REMAINDER
REMAINDER2:   .DATA.L _REMAINDER
        .ALIGN 4
_MSEC10: .DATA.L MSEC10_
FRUNS3_: .DATA.L FRUN
FSETS3_: .DATA.L FSET
	.ALIGN 4
LINEAR1:

	MOV ACC_LIN_R_,R0	;GET ACC_LIN_R TIME FOR COMPARE
	MOV @R0,R1

	MOV #10,R0		;SCALE TIME WITH 10
	MULS R0,R1
	STS MACL,R1

	MOV MSEC103,R0
	MOV @R0,R0
	CMP/EQ R1,R0		;IF TIME = ACC_LIN TIME
	BT  NONLIN		;THEN JMP TO SOFT ACCEL END
				;ELSE STILL IN LINEAR RANGE

	MOV INCREA3,R0		;COUNT TIME FOR LINEAR RANGE
	MOV @R0,R1		;COUNT EVERY 1MS.
	ADD #1,R1
	MOV R1,@R0		
	MOV #10,R2		;COUNT EVERY 10MS.
	CMP/EQ R2,R1
	BF NO10MSEC3
	MOV MSEC103,R3
	MOV @R3,R4
	ADD #1,R4
	MOV R4,@R3
	MOV #0,R5
	MOV R5,@R0
NO10MSEC3:
;-------CLASSICAL IDEA FOR LINEAR ACCEL-------------
;	MOV MSEC103,R3		;MOVE TIME FOR CAL TO R1
;	MOV @R3,R1
;	MOV AMAX_,R10
;	MOV @R10,R2
;	MULS R1,R2
;	STS MACL,R3
;	MOV #100,R4
;	DIVS R4,R3
;	MOV INITIAL1_,R10
;	MOV @R10,R2
;	ADD R2,R3
;	MOV FRUNS3,R0
;	MOV.W R3,@R0
;	BRA OUT_LOOP
;	NOP
;-------END OF CLASSICAL IDEA-----------------------
;-----NOVEL IDEA FOR LINEAR ACCEL-------------------
	MOV FRUNS3,R0		;GET FRUN(R2 = FRUN)
	MOV.W @R0,R2
	MOV C1000,R5		;SCALE FRUN WITH 1000
	MULS R2,R5
	STS MACL,R2
	MOV AMAX_,R3		;GET AMAX (R3 = AMAX)
	MOV @R3,R3
	ADD R3,R2		;FRUN=FRUN+AMAX*DT (DT=1MS)
	MOV REMAINDER,R7	;GET REMAINDER(R3=REMAINDER)
	MOV @R7,R3
	CMP/GE R5,R3		;IF REMAINDER < 1000
	BF NOT_ADD		;THEN NOT ADD REMAINDER 
	ADD R5,R2		;ELSE FRUN=FRUN+AMAX*DT+1000(REMAINDER)
	SUB R5,R3		;REMAINDER=REMAINDER-1000
	MOV R3,@R7
NOT_ADD:
	MOV R2,R4		
	MOV C1000,R6
	DIVS R6,R4		;SCALING FRUN
	MOV.W R4,@R0		;STORE FRUN 
	MOV C1000,R6
	MULS R6,R4
	STS MACL,R4
	SUB R4,R2		;FIND REMAINDER FROM DIVIDER
	MOV REMAINDER,R3
	MOV @R3,R4
	ADD R4,R2		;ADD OLD REMAINDER WITH NEW REMAINDER
	MOV R2,@R3 		;STORE REMAINDER
	BRA OUT_LOOP
	NOP
;----------END OF NOVEL IDEA---------------------------------		
NONLIN:
	.INCLUDE "S_CURVE2.H"		;SOFT ACCEL END RANGE
	BRA OUT_LOOP
	NOP
	.ALIGN 4

ACC_LIN_R_:.DATA.L _ACC_LIN_R
INCREA3: .DATA.L INCREA3_
FRUNS3:  .DATA.L FRUN
FSETS3:	 .DATA.L FSET
INITIAL0:.DATA.L 750
INITIAL1_: .DATA.L _INITIAL1
MSEC103:.DATA.L MSEC103_
REMAINDER: .DATA.L _REMAINDER
	.ALIGN 4

DEC_S_SHAPE:
	MOV SYSFLGD,R1
	MOV.B @R1,R0
	OR #B'100000,R0
	MOV.B R0,@R1
;-----CLEAR COUNTER OF S CURVE(ACCEL COUNTER) IF USER PRESS STP-KEY-----------
	MOV #0,R10
	MOV INCREA_A1,R0
	MOV R10,@R0
	MOV MSEC10_A1,R0
	MOV R10,@R0
	MOV INCREA2_A1,R0
	MOV R10,@R0
	MOV MSEC102_A1,R0
	MOV R10,@R0
	MOV INCREA3_A1,R0
	MOV R10,@R0
	MOV MSEC103_A1,R0
	MOV R10,@R0
	MOV REMAINDER1,R0
	MOV R10,@R0
;---------------------------------------------------------------------------	
;--------------------------------------------------------------------
;CHECK THAT WHEN FRUN NOT DECEL TO FSET IF FSET HAVE CHANGE
;(FSET CHANGE WHILE DECEL) THEN MUST CLEAR COUNTER OF DECEL S CURVE
;--------------------------------------------------------------------

        MOV D_FSETS,R0
        MOV.W @R0,R1
        MOV R1,R0
        CMP/EQ #0,R0            ;IF FSET = 0 (DECEL TO STP)
        BF  NOT_DCT
        MOV STPFRE1,R0          ;THEN USE STP_FRE REPLACE FSET
        MOV.W @R0,R1
NOT_DCT:

        MOV INITIALD,R0
        MOV @R0,R2
        SUB R1,R2
        MOV #20,R0
        MULS R0,R2
        STS MACL,R2             ;R2=(INITIALD-FSET)*20
        MOV D_DELTAF,R0
        MOV @R0,R1
        CMP/EQ R1,R2            ;IF R2=DELTAF
        BT  START_DECEL_S       ;THEN START_DECEL_S
        MOV #0,R10              ;ELSE CLEAR COUNTER OF DECEL_S(FSET HAVE CHANGE BEFORE FRUN=FSET)
        MOV INCREA_D2,R0
        MOV R10,@R0
        MOV MSEC10_D2,R0
        MOV R10,@R0
        MOV INCREA2_D2,R0
        MOV R10,@R0
        MOV MSEC102_D2,R0
        MOV R10,@R0
        MOV INCREA3_D2,R0
        MOV R10,@R0
        MOV MSEC103_D2,R0
        MOV R10,@R0
        MOV D_REMAINDER2,R0
        MOV R10,@R0

START_DECEL_S:
;---------------------------------------------------------------------------------
;CALCULATE PARAMETER(DMAX,D_KRATE1,D_KRATE2,D_INITIAL1,D_INITIAL2)FOR S_CURVE(DEC)
;---------------------------------------------------------------------------------
	MOV D_MSEC10,R0
	MOV @R0,R0
	CMP/EQ #0,R0		;IF NOT FIRST TIME TO DECEL_S_CURVE
	BF  D_NOT_FIRST   	;THEN SKIP TO CALCULATE PARAMETER
	MOV D_FRUNS,R0		;ELSE STORE FRUN FOR INITIAL VALUE
	MOV.W @R0,R1
	MOV INITIALD,R0
	MOV R1,@R0
	MOV D_FSETS,R0
	MOV.W @R0,R2

	MOV R2,R0
	CMP/EQ #0,R0
	BF  FSET_NOT_CHANGE
	MOV STPFRE1,R0
	MOV.W @R0,R2
	MOV D_FSETS,R0
	MOV.W R2,@R0		
FSET_NOT_CHANGE:
	MOV D_FSETS,R0
	MOV.W @R0,R2

	SUB R2,R1
	MOV R1,R2
	SHLL R1

	
	MOV #10,R0
	MULS R0,R2
	STS MACL,R2
	SHLL R2
	MOV D_DELTAF,R0		;CALCULATE 2*|FRUN(INITIAL)-FSET|
	MOV R2,@R0

	MOV D_SQROOT,R14	;FIND SCALE FACTOR {SQRT(|FSET-FRUN|/50Hz)}
	JSR @R14;SQ_ROOT	;R13 = SCALE FACTOR	
	NOP
	

	MOV DEC_START,R0
	MOV @R0,R1
	MULS R1,R13
	STS MACL,R1
	MOV #100,R12
	DIVS R12,R1
	MOV DEC_START_R,R0	;DEC_START_R = SCALE FACTOR*DEC_START
	MOV R1,@R0	
	
	MOV DEC_LIN,R0
	MOV @R0,R2
	MULS R2,R13
	STS MACL,R2
	MOV #100,R12
	DIVS R12,R2
	MOV DEC_LIN_R,R0	;DEC_LIN_R = SCALE FACTOR*DEC_LIN
	MOV R2,@R0

	MOV DEC_END,R0
	MOV @R0,R3
	MULS R3,R13
	STS MACL,R3
	MOV #100,R12
	DIVS R12,R3
	MOV DEC_END_R,R0	;DEC_END_R = SCALE FACTOR*DEC_END
	MOV R3,@R0
	
D_NOT_FIRST:
	MOV DEC_START_R,R0	;R1 = DEC_START_R (TIME FOR DECEL START-
	MOV @R0,R1		;WHEN MULTIPLIED BY SCALE FACTOR)

	MOV DEC_LIN_R,R0	;R2 = DEC_LIN_R (TIME FOR DECEL LINEAR-
	MOV @R0,R2		;WHEN MULTIPLIED BY SCALE FACTOR)

	MOV DEC_END_R,R0	;R3 = DEC_END_R (TIME FOR DECEL END-
	MOV @R0,R3		;WHEN MULTIPLIED BY SCALE FACTOR)

	MOV R2,R4
	MOV R1,R6
	SHLL R4
	ADD R1,R4
	ADD R3,R4

	MOV D_DELTAF,R5		
	MOV @R5,R5

	DIVS R4,R5
	MOV DMAX,R0		;DMAX=2*|FRUN(INITIAL)-FSET|/(T1+2*T2+T3)	
	MOV R5,@R0
	MOV R5,R7
	MOV R5,R8
	DIVS R1,R5
	MOV D_KRATE1,R0		;D_KRATE1=DMAX/T1
	MOV R5,@R0
	MULS R5,R6
	STS MACL,R5
	MULS R5,R6
	STS MACL,R5
	SHAR R5
	MOV #10,R10
	DIVS R10,R5
	MOV INITIALD,R13
	MOV @R13,R13
	SUB R5,R13
	MOV D_INITIAL1,R0	;D_INITIAL1=0.5*D_KRATE1*T1^2/1000
	MOV R13,@R0
	DIVS R3,R7
	MOV D_KRATE2,R0		;D_KRATE2=DMAX/T3
	MOV R7,@R0
	MULS R2,R8		
	STS MACL,R8
	MOV #10,R10
	DIVS R10,R8
	SUB R8,R13
	MOV D_INITIAL2,R0	;D_INITIAL2=D_INITIAL1+(DMAX*T2)/1000
	MOV R13,@R0	

;---------------------------------------------------------------
	MOV DEC_START_R,R0
	MOV @R0,R1
	MOV #10,R0
	MULS R0,R1
	STS MACL,R1
	MOV _D_MSEC10,R0
	MOV @R0,R0
	CMP/EQ R1,R0		;IF TIME = DEC_START TIME
	BT LINEARD1  		;THEN CHANGE TO LINEAR DECEL RANGE
	.INCLUDE "SCURVE1D.H"	;ELSE STILL IN SOFT DECEL START RANGE
	BRA OUT_LOOP
	NOP
LINEARD1:
	BRA LINEARD		;FOR SOLVING REFERENCE SYMBOL TOO FAR
	NOP
	.ALIGN 4 
D1000:   .DATA.L 1000
D_DELTAF:  .DATA.L _D_DELTAF
DMAX:    .DATA.L _DMAX
DEC_START: .DATA.L _DEC_START
DEC_LIN:   .DATA.L _DEC_LIN
DEC_END:   .DATA.L _DEC_END
D_KRATE1:    .DATA.L _D_KRATE1
D_KRATE2:    .DATA.L _D_KRATE2
D_INITIAL1:  .DATA.L _D_INITIAL1
D_INITIAL2:  .DATA.L _D_INITIAL2
INITIALD:    .DATA.L _INITIALD
_D_MSEC10:    .DATA.L D_MSEC10_
D_SQROOT:  .DATA.L SQ_ROOT
DEC_START_R: .DATA.L _DEC_START_R
DEC_LIN_R:   .DATA.L _DEC_LIN_R
DEC_END_R:   .DATA.L _DEC_END_R
INCREA_A1:  .DATA.L INCREA_
INCREA2_A1: .DATA.L INCREA2_
INCREA3_A1: .DATA.L INCREA3_
MSEC10_A1:  .DATA.L MSEC10_
MSEC102_A1: .DATA.L MSEC102_
MSEC103_A1: .DATA.L MSEC103_
REMAINDER1: .DATA.L _REMAINDER
STPFRE1:    .DATA.L _STP_FRE
SYSFLGD:    .DATA.L SYSFLG
INCREA_D2:  .DATA.L D_INCREA_
INCREA2_D2: .DATA.L D_INCREA2_
INCREA3_D2: .DATA.L D_INCREA3_
MSEC10_D2:  .DATA.L D_MSEC10_
MSEC102_D2: .DATA.L D_MSEC102_
MSEC103_D2: .DATA.L D_MSEC103_
D_REMAINDER2: .DATA.L _D_REMAINDER
        .ALIGN 4
LINEARD:			;LINEAR DECEL RANGE
	MOV DEC_LIN_R_,R0
	MOV @R0,R1
	MOV #10,R0
	MULS R0,R1
	STS MACL,R1
	MOV D_MSEC103,R0
	MOV @R0,R0
	CMP/EQ R1,R0		;IF TIME = LINEAR DECEL TIME
	BT  D_NONLIN		;THEN CHANGE TO SOFT DECEL END RANGE
				;ELSE STILL IN LINEAR DECEL RANGE

	MOV D_INCREA3,R0	;COUNT TIME FOR LINEAR RANGE
	MOV @R0,R1		;COUNT EVERY 1MS.
	ADD #1,R1
	MOV R1,@R0		
	MOV #10,R2		;COUNT EVERY 10MS.
	CMP/EQ R2,R1
	BF D_NO10MSEC3
	MOV D_MSEC103,R3
	MOV @R3,R4
	ADD #1,R4
	MOV R4,@R3
	MOV #0,R5
	MOV R5,@R0
D_NO10MSEC3:
;-----NOVEL IDEA FOR LINEAR DECEL-------------------
	MOV D_FRUNS3,R0		;GET FRUN(R2 = FRUN)
	MOV.W @R0,R2
	MOV DC1000,R5		;SCALE FRUN WITH 1000
	MULS R2,R5
	STS MACL,R2
	MOV DMAX_,R3		;GET DMAX (R3 = DMAX)
	MOV @R3,R3
	SUB R3,R2		;FRUN=FRUN-DMAX*DT (DT=1MS)
	MOV D_REMAINDER,R7	;GET REMAINDER(R3=REMAINDER)
	MOV @R7,R3
	CMP/GE R5,R3		;IF REMAINDER < 1000
	BF D_NOT_ADD		;THEN NOT ADD REMAINDER 
	ADD R5,R2		;ELSE FRUN=FRUN-DMAX*DT-1000(REMAINDER)
	SUB R5,R3		;REMAINDER=REMAINDER-1000
	MOV R3,@R7
D_NOT_ADD:
	MOV R2,R4		
	MOV DC1000,R6
	DIVS R6,R4		;SCALING FRUN
	MOV.W R4,@R0		;STORE FRUN 
	MOV DC1000,R6
	MULS R6,R4
	STS MACL,R4
	SUB R4,R2		;FIND REMAINDER FROM DIVIDER
	MOV D_REMAINDER,R3
	MOV @R3,R4
	ADD R4,R2		;ADD OLD REMAINDER WITH NEW REMAINDER
	MOV R2,@R3 		;STORE REMAINDER
	BRA OUT_LOOP
	NOP
;----------END OF NOVEL IDEA---------------------------------		
;------CLASSICAL IDEA FOR LINEAR DECEL-----------------------
;	MOV D_MSEC103,R3		;MOVE TIME FOR CAL TO R1
;	MOV @R3,R1
;	MOV DMAX_,R10
;	MOV @R10,R2
;	MULS R1,R2
;	STS MACL,R3
;	MOV #100,R4
;	DIVS R4,R3
;	MOV D_INITIAL1_,R10
;	MOV @R10,R2
;	SUB R3,R2
;	MOV D_FRUNS3,R0
;	MOV.W R2,@R0
;	BRA OUT_LOOP
;	NOP
;--------END OF CLASSICAL IDEA-------------------------------------
D_NONLIN:
	.INCLUDE "SCURVE2D.H"		;SOFT DECEL END RANGE
	BRA OUT_LOOP
	NOP

        .ALIGN 4
DEC_LIN_R_:   .DATA.L _DEC_LIN_R
D_MSEC103:    .DATA.L D_MSEC103_
D_INCREA3:    .DATA.L D_INCREA3_
DMAX_:        .DATA.L _DMAX
DC1000:       .DATA.L 1000
D_INITIAL1_:  .DATA.L _D_INITIAL1
D_REMAINDER:  .DATA.L _D_REMAINDER
        .ALIGN 4

OUT_LOOP:
	MOV D_FRUNS3,R0
	MOV.W @R0,R10
	MOV FRE_RPM,R14
	JSR @R14;FRE_TO_RPM
	NOP
	MOV RPM,R0
	MOV.W R1,@R0
	MOV MCSPEED,R0
        MOV.L R2,@R0

	MOV DISP_TYPE1,R0
	MOV.B @R0,R6
	MOV #2,R5
	CMP/GE R5,R6			;IF DISPLAY Hz & AMP
	BF  OUT_OUT			;THEN OUT_OUT
	MOV RSTATUS5,R0
	MOV.B @R0,R0
	TST #B'10000000,R0		;IF EXTERNAL SPEED FLAG SET
	BF  OUT_OUT			;THEN OUT_OUT
	MOV FLASTS3,R0
	MOV.W @R0,R0
	CMP/EQ R0,R10			;IF FRUN<>FLAST
	BF OUT_OUT			;THEN OUT_OUT
	CMP/EQ R5,R6			;IF DISPLAY RPM
	BF MACHINE			;IF DISPLAY MCSPEED THEN CHECK MCLAST
	MOV RPMLAST3,R0			;THEN CHECK RPMLAST
	MOV.W @R0,R0
	CMP/EQ R0,R1			;IF RPMLAST = RPMRUN
	BT OUT_OUT			;THEN OUT_OUT
	MOV RPM,R4
	MOV.W R0,@R4			;ELSE STORE RPMLAST TO RPMRUN
	BRA OUT_OUT
	NOP
        .ALIGN 4
RPM:        .DATA.L _RPM
FRE_RPM:    .DATA.L FRE_TO_RPM
DISP_TYPE1: .DATA.L _DISP_TYPE
RSTATUS5:   .DATA.L _R_STATUS
D_FRUNS3:   .DATA.L FRUN
FLASTS3:    .DATA.L FLAST
RPMLAST3:   .DATA.L _RPM_LAST
        .ALIGN 4
MACHINE:
	MOV MCLAST3,R0
        MOV.L @R0,R0
	CMP/EQ R0,R2			;IF MCLAST = MCRUN
	BT  OUT_OUT			;THEN OUT_OUT
	MOV MCSPEED,R7
        MOV.L R0,@R7                    ;ELSE STORE MCLAST TO MCRUN
OUT_OUT:
	.INCLUDE "OL2.H"
        .INCLUDE "SEARCH.H"             ;FLYING

        MOV D_FRUNS4,R0                 ;GENERATE FOUT
        MOV.W @R0,R10
        MOV TBASEA,R1
        MULS R1,R10
        STS MACL,R1
        MOV D_FSAT,R0
        MOV.W @R0,R10
        DIVS R10,R1
        MOV GRB0,R0
        MOV.W R1,@R0

        MOV USTATUS5,R3
        MOV.B @R3,R0
        MOV D_FRUNS4,R1
        MOV.W @R1,R1
        MOV D_FSETS3,R2
        MOV.W @R2,R2
        CMP/EQ R1,R2                    ;IF FRUN=FSET
        BT  STEADY                      ;THEN SET STEADY FLAG
        AND #B'11101111,R0              ;ELSE CLEAR FLAG
        MOV.B R0,@R3
        LDS.L @SP+,PR
        RTS
        NOP
STEADY:
        OR #B'10000,R0
        MOV.B R0,@R3
        LDS.L @SP+,PR
        RTS
        NOP

        LDS.L @SP+,PR
        RTS
        NOP
	.ALIGN 4
D_FSETS3: .DATA.L FSET
USTATUS5:  .DATA.L _U_STATUS
TBASEA:    .DATA.L 20000
GRB0:      .DATA.L H'5FFFF0C
D_FSAT:    .DATA.L _F_SAT
D_FRUNS4:  .DATA.L FRUN

        ;*********************************
        ; SCAN DISPLAY AND KEY SUBROUTINE
        ; DATA TRANSFER THROUGH DATA_BUF
        ; DATA_BUF+3..+0=MSB DIGIT..LSB DIGIT
        ; DATA_BUF+4=LED DIGIT
        ;*********************************
        .ALIGN 4
SCAN:
        STS.L  PR,@-SP
	MOV TSTATUS1,R1
	MOV.B @R1,R0
	TST #B'1,R0
	BT  SLOW_BLK
	MOV FASTBLK,R2
	MOV BT_DAT,R1
	MOV.W R2,@R1
	BRA SCAN_1
	NOP
SLOW_BLK:
	MOV SLOWBLK,R2
	MOV BT_DAT,R1
	MOV.W R2,@R1

SCAN_1:	
        MOV DATA_BUF,R10           ;R10 CONTAIN ADDR. OF DATA_BUF
        MOV DIG_CNT,R0             ;R2 CONTAIN ADDR. OF DIGIT COUNT
        MOV.B @R0,R0               ;MOVE ADDR. IN R2 TO R2
        MOV R0,R1                  ;STROE DIG_CNT->R1
        MOV #0,R2
        CMP/GE R2,R0
        BT  SCAN1
        MOV #4,R0
SCAN1:  ADD R0,R10                 ;R10=R10+R2 (DATA BUFFER+R2)
        MOV.B @R10,R4              ;STORE TO R4
        MOV POINT0,R0
        MOV.B @R0,R0
        CMP/EQ R0,R1               ;IF POINT=DIG_CNT FILL POINT
        BT  POINT_FILL
        BRA NO_FILL                ;ELSE NOT FILL
        NOP
POINT_FILL:
        MOV #B'10000000,R1
        OR  R1,R4

NO_FILL:

        MOV DIGIT,R1               ;R1 CONTAIN ADDR. OF DIGIT
        MOV.B @R1,R0               ;MOV ADDR. IN R1 TO R0 (SIGN EXTEND)
        MOV MASK,R2                ;MASK TO 8 BIT
        AND R2,R0
        CMP/EQ #0,R0               ;IF DIGIT IS SHIFTED FROM 00001000 TO 0
        BT RESET_DIGIT             ;BRANCE TO RESET_DIGIT
        SHLL R0                    ;ELSE SHIFT DIGIT LEFT
        MOV DIG_CNT,R1
        MOV.B @R1,R2
        ADD #-1,R2                  ;DECRESE DIGIT COUNT
        MOV.B R2,@R1
        MOV TMP_DIG0,R1
        MOV.B @R1,R2
        ADD #-1,R2
        MOV.B R2,@R1
        BRA INC_DIGIT
        NOP
RESET_DIGIT:
        MOV #B'00001000,R0         ;
        MOV DIG_CNT,R1
        MOV #3,R2
        MOV.B R2,@R1
        MOV TMP_DIG0,R1
        MOV #5,R2
        MOV.B R2,@R1

INC_DIGIT:

        MOV   DIGIT,R1
        MOV.B R0,@R1               ;SAVE DIGIT IS SHIFTED BACK TO DIGIT
        SHLL8 R0                   ;SHIFT TO HIGH WORD

        MOV MASK,R2
        AND R2,R4                  ;

        OR R0,R4

        MOV #0,R10                 ;OFF DIGIT
        MOV TRX1WD,R0
        JSR @R0;TRX1WORD
        NOP

        BSR SCANK
        NOP

        MOV SYSFLG2,R0
        MOV.B @R0,R0
        TST #1,R0                  ;CHECK SYSFLG.0
        BT  CHK_BLNKT              ;IF R0&1 = 0 THEN T=1 ELSE T=0(FAULTS)
        MOV DIG_TOG,R0
        MOV.B @R0,R0
        CMP/EQ #4,R0
        BF CHK_BLNKT
        BRA OUT_DAT1               ;ELSE = PROG MODE OR RUN MODE
        NOP
CHK_BLNKT:
        MOV BLNKT2,R1              ;LOAD BLINK TIME VARIABLE
        MOV.W @R1,R0

        MOV BT_DAT,R2              ;LOAD BLINK TIME
        MOV.W @R2,R2
        CMP/GE R2,R0               ;IF VARIABLE >= R2 BRANCE OUT_DAT
        BT  OUT_DAT
        ADD #1,R0                  ;INC VARIABLE
        MOV.W R0,@R1
        MOV #0,R10

        MOV DIGIT,R1
        MOV.B @R1,R10               ;SAVE DIGIT IS SHIFTED BACK TO DIGIT
        SHLL8 R10                   ;SHIFT TO HIGH WORD
        MOV DIG_CNT,R2             ;R2 CONTAIN ADDR. OF DIGIT COUNT
        MOV.B @R2,R2               ;MOVE ADDR. IN R2 TO R2
        ADD #1,R2
        MOV DIG_TOG,R1
        MOV.B @R1,R1
        MOV SYSFLG2,R0
        MOV.B @R0,R0
        TST #B'100,R0
        BF CHK_NEQ
        TST #B'10,R0
        BF CHK_NEQ
CHK_EQ:
;        TST #B'10,R0               ;IF PROGRAM MODE
;        BF CHK_NEQ                 ;THEN CHK_NEQ
        CMP/EQ R1,R2
        BT OUT_DAT1
        BRA OUT_S0                 ;NOT OUT DATA
        NOP
CHK_NEQ:
        MOV TSTATUS1,R0
        MOV.B @R0,R0
        TST #B'1,R0
        BF  CHK_EQ

        CMP/EQ R1,R2
        BF OUT_DAT1
        BRA OUT_S0                 ;NOT OUT DATA
        NOP
OUT_DAT:
        MOV BT_DAT,R2
        MOV.W @R2,R2
        SHAL R2                    ;BLINK TIME x 2
        CMP/EQ R2,R0               ;IF VARIABLE=BLINK TIME x 2 CLR VARIABLE
        BF  INC_BLNKT              ;ELSE JUMP TO INC VARIABLE
        MOV #0,R0                  ;CLR VARIABLE
        BRA ST_BLNK
        NOP
INC_BLNKT:
        ADD #1,R0
ST_BLNK:MOV.W R0,@R1               ;SAVE VARIBLE
OUT_DAT1:
        MOV R4,R10                 ;OUT DATA
OUT_S0:
        MOV TRX1WD,R0
        JSR @R0;TRX1WORD
        NOP

;        MOV #0,R10                 ;OFF DIGIT
;        BSR TRX1WORD
;        NOP

;        BSR SCANK
;        NOP

        LDS.L  @SP+,PR
        RTS
        NOP

            .ALIGN 4
DIGIT:      .DATA.L _DIGIT
DIG_CNT:    .DATA.L _DIG_CNT
TMP_DIG0:   .DATA.L TMP_DIG
DATA_BUF:   .DATA.L _DATA_BUF
TCOUNT:     .DATA.L _TCOUNT
MASK:       .DATA.L H'FF
BLNKT2:     .DATA.L BLNKT
SYSFLG2:    .DATA.L SYSFLG
BT_DAT:     .DATA.L _BT_DAT;H'2FF/2
FASTBLK:    .DATA.L H'5F/2
SLOWBLK:    .DATA.L H'2FF/2
TSTATUS1:   .DATA.L _T_STATUS
POINT0:     .DATA.L POINT
B7:         .DATA.L B'10000000
TRX1WD:     .DATA.L TRX1WORD
DIG_TOG:    .DATA.L _DIG_TOG
            ;**********************************
            ; SCAN KEY BOARD SUB ROUTINE
            ;**********************************
            .ALIGN 4
SCANK:
            STS.L  PR,@-SP
            MOV    INPORT3,R0
            MOV.W  @R0,R0
            MOV    MASKK,R1
            AND    R1,R0

            CMP/EQ R0,R1
            BF     KEYPRESS

;***********KEY NOT PRESS
        MOV TIMES,R2
        MOV.W @R2,R0
        MOV V20000,R3
        CMP/GE R3,R0            ;IF USER NOT PRESS ANY KEY GREATER THAN 20 SEC.
        BT  SEC20               ;THEN JMP TO SEC20
        ADD #1,R0               ;ELSE INC. TIMES
        MOV.W R0,@R2
        BRA NOT_PRESS
        NOP
SEC20:  MOV #0,R0               ;CLEAR TIMES TO ZERO
        MOV.W R0,@R2
        MOV DIGTOG3,R2
        MOV #4,R0               ;SET NORMAL DISPLAY
        MOV.B R0,@R2
NOT_PRESS:

            MOV    SYSFLG3,R2
            MOV.B  @R2,R0
            TST    #B'10000000,R0        ;IF SYSFLG.7=1 (T=0) KEY PRESS BEFORE
            BT     CLR_ALL
            BRA    KEY_PBF
            NOP

CLR_ALL:    MOV    OLDDIG1,R0
            MOV    #0,R1
            MOV.B  R1,@R0
            MOV    OLDKEY1,R0
            MOV.B  R1,@R0
            MOV    KEYDELAY0,R0
            MOV    KDELY,R1
            MOV.B  R1,@R0
            MOV    KEYDLY0,R0
            MOV    KDLY,R1
            MOV.B  R1,@R0
            MOV    SYSFLG3,R0
            MOV.B  @R0,R1
            MOV    #B'10111111,R2
            AND    R2,R1
            MOV.B  R1,@R0
            MOV    DSP_SWP1,R1
            MOV.W  @R1,R0
            CMP/EQ #0,R0
            BT     CLR_KC
            ADD    #-1,R0
            MOV.W  R0,@R1

CLR_KC:     MOV    KEYCODE1,R0
            MOV    #0,R1
            MOV.B  R1,@R0
            BRA    OUT_SCANK
            NOP

KEY_PBF:    ;NOW KEY NOT PRESS BUT IT MAY BE THE OTHER DIGIT
            MOV    OLDDIG1,R14
            MOV.B  @R14,R0
            MOV    TMP_DIG1,R1
            MOV.B  @R1,R1
            CMP/EQ R1,R0        ;CHECK IS THE SAME DIGIT WITH PRESSED BEFORE?
            BF     CLR_KC

            MOV    DBOUNCE1,R1
            MOV.B  @R1,R0
            ADD    #-1,R0
            MOV.B  R0,@R1
            CMP/EQ #0,R0
            BT     RST_SYS7
            BRA    OUT_SCANK
            NOP

RST_SYS7:   MOV    #3,R0
            MOV.B  R0,@R1
            MOV    SYSFLG3,R0
            MOV.B  @R0,R1
            MOV    R_SYS7,R2
            AND    R2,R1
            MOV.B  R1,@R0
            BRA    CLR_ALL
            NOP

KEYPRESS:
            MOV TIMES,R2
            MOV #0,R1
            MOV.W R1,@R2                ;WHEN USER PRESS ANY KEY CLEAR TIMES
            SWAP.B R0,R0
            SWAP.W R0,R0
            ROTL   R0
            ROTL   R0

            MOV    TMP_DIG1,R1
            MOV.B  @R1,R1
            MOV    OLDDIG1,R14
            MOV.B  R1,@R14
            CMP/EQ #2,R0
            BT     ADD6
            ADD    #1,R1
            BRA    SCANK3
            NOP
ADD6:       ADD    #6,R1

SCANK3:     MOV    R1,R13
            MOV    SYSFLG3,R2
            MOV.B  @R2,R0
            TST    #B'10000000,R0        ;IF SYSFLG.7=1 (T=0) KEY PRESS BEFORE
            BF     KEY_BF
            BRA    KEY_NBF
            NOP

KEY_BF:     MOV    DBOUNCE1,R1
            MOV.B  @R1,R0
            ADD    #-1,R0
            MOV.B  R0,@R1
            CMP/EQ #0,R0
            BT     KBF1
            BRA    OUT_SCANK
            NOP

KBF1:       MOV    #3,R0
            MOV.B  R0,@R1
            BRA    CHK_AUTO;OUT_SCANK
            NOP

KEY_NBF:    MOV    S_SYS7,R3
            OR     R3,R0                 ;SET SYSFLG.7
            MOV    #B'10011111,R3
            AND    R3,R0
            MOV.B  R0,@R2                ;CLEAR SYSFLG.6,.5
            MOV    OLDKEY1,R0
            MOV.B  R13,@R0               ;SAVE KEYCODE TO OLDKEY
            MOV    KEYCODE1,R0
            MOV.B  R13,@R0               ;"            "  KEYCODE
            MOV    KEYDLY0,R0
            MOV    KDLY,R1               ;KDLY=H'5F
            MOV.B  R1,@R0                ;KEYDLY<=KDLY
            BRA    OUT_SCANK
            NOP

CHK_AUTO:
            MOV    R13,R0
            CMP/EQ #UPKEY,R0
            BF     DWNKEY
            BRA    SCANK6
            NOP
DWNKEY:
            CMP/EQ #DOWNKEY,R0
            BF     STOPK
            BRA    SCANK6
            NOP
STOPK:
            CMP/EQ #STOPKEY,R0
            BF     SHIFTK
            BRA    SCANK6
            NOP
SHIFTK:
            CMP/EQ #SHIFTKEY,R0
            BT     SCANK6

            MOV    OLDKEY1,R1
            MOV.B  @R1,R1
            CMP/EQ R0,R1
            BF     SCANK66
;            MOV    KEYCODE1,R0
;            MOV    #0,R1
;            MOV.B  R1,@R0
;            MOV    OLDKEY1,R0
;            MOV.B  R1,@R0
            BRA    OUT_SCANK
            NOP
SCANK66:
            MOV    SYSFLG3,R0
            MOV.B  @R0,R1
            MOV    R_SYS7,R2
            AND    R1,R2
            MOV.B  R2,@R0
            BRA    OUT_SCANK
            NOP

SCANK6:
            MOV    OLDKEY1,R0
            MOV.B  @R0,R0
            CMP/EQ #UPKEY,R0
            BF     DWNKEY1
            CMP/EQ R0,R13
            BT     SCANK61
            MOV    OLDKEY1,R0
            MOV    #0,R1
            MOV.B  R1,@R0
            MOV    KEYDELAY0,R0
            MOV    KDELY,R1
            MOV.B  R1,@R0
            BRA    OUT_SCANK
            NOP

DWNKEY1:
            CMP/EQ #DOWNKEY,R0
            BF     STOPK1
            CMP/EQ R0,R13
            BT     SCANK61
            MOV    OLDKEY1,R0
            MOV    #0,R1
            MOV.B  R1,@R0
            MOV    KEYDELAY0,R0
            MOV    KDELY,R1
            MOV.B  R1,@R0
            BRA    OUT_SCANK
            NOP

STOPK1:
            CMP/EQ #STOPKEY,R0
            BF     SHIFTK1
            CMP/EQ R0,R13
            BT     SCANK61
            MOV    OLDKEY1,R0
            MOV    #0,R1
            MOV.B  R1,@R0
            MOV    KEYDELAY0,R0
            MOV    KDELY,R1
            MOV.B  R1,@R0
            BRA    OUT_SCANK
            NOP

SHIFTK1:
            CMP/EQ #SHIFTKEY,R0
            BT     SHFT6
            MOV    OLDKEY1,R0
            MOV    #0,R1
            MOV.B  R1,@R0
            MOV    KEYDELAY0,R0
            MOV    KDELY,R1
            MOV.B  R1,@R0
            BRA    OUT_SCANK
            NOP
SHFT6:
            CMP/EQ R0,R13
            BT     SCANK61
            MOV    OLDKEY1,R0
            MOV    #0,R1
            MOV.B  R1,@R0
            MOV    KEYDELAY0,R0
            MOV    KDELY,R1
            MOV.B  R1,@R0
            BRA    OUT_SCANK
            NOP

SCANK61:;***AUTO REPEAT
            MOV    KEYDLY0,R1
            MOV.B  @R1,R0
            ADD    #-1,R0
            MOV.B  R0,@R1
            CMP/EQ #0,R0
            BF     SCANK_62
            MOV    KEYDELAY0,R2
            MOV.B  @R2,R0
            CMP/EQ #0,R0
            BT     SCNK62
            ADD    #-1,R0
            MOV.B  R0,@R2
SCNK62:     BRA    SCANK62
            NOP
SCANK_62:
            MOV    SYSFLG3,R1
            MOV.B  @R1,R0
            TST    #B'01000000,R0
            BF     OUT_SCANK
            MOV    #B'01000000,R2
            OR     R0,R2
            MOV.B  R2,@R1
            BRA    OUT_SCANK
            NOP
SCANK62:
            MOV    SYSFLG3,R0
            MOV.B  @R0,R1
            MOV    #B'10111111,R2
            AND    R1,R2
            MOV.B  R2,@R0
            MOV    KEYCODE1,R0
            MOV.B  R13,@R0
            MOV    OLDKEY1,R0
            MOV.B  R13,@R0
            MOV    KEYDLY0,R0
            MOV    KDLY1,R1
            MOV.B  R1,@R0
            ;BRA    OUT_SCANK
            ;NOP

OUT_SCANK:
            LDS.L  @SP+,PR
            RTS
            NOP

            .ALIGN 4
INPORT3:    .DATA.L INPORT
KEYCODE1:   .DATA.L KEYCODE
OLDKEY1:    .DATA.L OLDKEY
OLDDIG1:    .DATA.L OLDDIG
DIG_CNT1:   .DATA.L _DIG_CNT
TMP_DIG1:   .DATA.L TMP_DIG
SYSFLG3:    .DATA.L SYSFLG
MASK16:     .DATA.L H'FFFF
MASKK:      .DATA.L B'11000000
R_SYS7:     .DATA.L H'FF7F
S_SYS7:     .DATA.L H'80
KDELY:      .DATA.L H'78
KDLY:       .DATA.L H'40
KDLY1:      .DATA.L H'8
KEYDELAY0:  .DATA.L KEYDELAY
KEYDLY0:    .DATA.L KEYDLY
DBOUNCE1:   .DATA.L DBOUNCE
DSP_SWP1:   .DATA.L DISP_SWAP
TIMES:      .DATA.L _TIMES
DIGTOG3:    .DATA.L _DIG_TOG
V20000:     .DATA.L 20000       ;TIME FOR RETURN TO NORMAL DISPLAY(DIGTOG=4)

            .ALIGN 4
DELAY:
            MOV R10,R0
CMP_A:      CMP/EQ #0,R0
            BT RET_DLAY
            ADD #-1,R0
            BRA CMP_A
            NOP
RET_DLAY:
            RTS
            NOP
        .INCLUDE "TUNNING.H"

          .SECTION DATA,DATA,ALIGN=4
          .INCLUDE "RAM.H"
;**********************
;    EQUAL VALUE
;**********************
;*********
;KEY CODE
;*********
SHIFTKEY:     .EQU     6
STOPKEY:      .EQU     2
RUNKEY:       .EQU     3
PROGKEY:      .EQU     4
SPARE1:       .EQU     5
SETKEY:       .EQU     1
DOWNKEY:      .EQU     7
UPKEY:        .EQU     8
RESETKEY:     .EQU     9
;*****************************************
; MAX. FUNCTION USE FOR HANDLE IN EEPROM
;*****************************************
MAXPROG:      .EQU     5000
;**********************
; EEPROM CONSTANT
;**********************
FUNC_MAX:     .EQU     64       ;FUNCTION CAN BE HAVE
                               ;(LOCATION IN EEPROM,LAST REG. FOR CHECKSUM)
FUNC_USE:     .EQU     63
CKSUM_AD:     .EQU     63
SLOW_KEY:     .EQU     H'0FE
FAST_KEY:     .EQU     H'0FB
;**************
; MATH EQU
;**************
SQR2X1000:    .EQU     1414
SQR3X1000:    .EQU     1732
PIX1000:      .EQU     3142
V_BASE:       .EQU     2540   ;v_mag
VB_2NEG:      .EQU     -1270  ;

;******************************** wark area **********************************
          .SECTION STACK,STACK,ALIGN=4
          .RES.L 100
_POWER_RESET_SP:
_MANUAL_RESET_SP:
;PROG_END:
MAIN_END:
          .END
